<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:RTCppProperties="http://www.eclipse.org/papyrus/umlrt/cppproperties" xmlns:UMLRTStateMachines="http://www.eclipse.org/papyrus/umlrt/statemachine" xmlns:UMLRealTime="http://www.eclipse.org/papyrus/umlrt" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML">
  <uml:Model xmi:id="_fuzjcGdiEeiqifykceCvxw" name="mCUTE">
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_fuzjcWdiEeiqifykceCvxw" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_fuzjcmdiEeiqifykceCvxw" key="language" value="umlrt-cpp"/>
    </eAnnotations>
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_XBD94GgrEeijRtS4FXxxtA" source="UMLRT_Default_top">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_XBEk8GgrEeijRtS4FXxxtA" key="top_name" value="MCUTE____DRC"/>
    </eAnnotations>
    <packagedElement xmi:type="uml:Class" xmi:id="_hpaO8GdiEeiqifykceCvxw" name="Global_Var_Test" classifierBehavior="_jPbKgGdiEeiqifykceCvxw" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_GQwmUGdjEeiqifykceCvxw" name="protocol1" type="_oIRIwGdiEeiqifykceCvxw" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_OePlIGdjEeiqifykceCvxw" name="Temprature" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_OePlIWdjEeiqifykceCvxw" value="0"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_M4ddoGdkEeiqifykceCvxw" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_ugLW4GgvEeijRtS4FXxxtA" name="cuteCommands" visibility="public" type="_FiiUsGgvEeijRtS4FXxxtA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_dTSeIH8aEeipA49rzMw2KQ" name="DesiredLevel" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_dTSeIX8aEeipA49rzMw2KQ" value="0"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_-d3XEICjEeib_vS042iOdQ" name="HighTemps" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_-d3XEYCjEeib_vS042iOdQ" value="0"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_7W70QORtEeiwK5UPZ22vmQ" name="_LoopBack" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_7W70QeRtEeiwK5UPZ22vmQ" value="0"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Property" xmi:id="_RCFV0PEWEeiEK7ZB4QGZMA" name="Warnings" visibility="public">
        <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_RCFV0fEWEeiEK7ZB4QGZMA" value="0"/>
      </ownedAttribute>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_jPbKgGdiEeiqifykceCvxw" name="DRCStateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_jRBF8GdiEeiqifykceCvxw" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_jROhUGdiEeiqifykceCvxw" name="Initial" source="_jREJQGdiEeiqifykceCvxw" target="_bigO0N7GEeiBkYD2qJeUwg">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_Lx3LcGg0EeijRtS4FXxxtA" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>//cuteCommands.newTransition(INITIAL).send();
//default values
DesiredLevel=5;
Temprature=50;
//Time=20;

//Initializing the Symbolic Interpreter
//__CrestInit();

</body>
            </effect>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_yFV14GdiEeiqifykceCvxw" name="t2" source="_jRLeAGdiEeiqifykceCvxw" target="_xgSBAGdiEeiqifykceCvxw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_rbYGAGdnEeijRtS4FXxxtA" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>int strategy;
std::ifstream ifs (&quot;strategy&quot;, std::ifstream::in);
ifs >> strategy;
if (strategy!=2){
  //Initializing the Symbolic Interpreter
  __CrestInit();

}
ifs.close();

  int __retres2 ;

   __CrestCall(1, 1);
  __CrestLoad(4, (unsigned long )(&amp; HighTemps), (long long )HighTemps);
  __CrestLoad(3, (unsigned long )0, (long long )10);
  __CrestApply2(2, 17, (long long )(HighTemps >= 10));
#line 11
  if (HighTemps >= 10) {
    __CrestBranch(5, 9, 1);
    __CrestLoad(7, (unsigned long )(&amp; HighTemps), (long long )HighTemps);
#line 12
    printf((char const   * __restrict  )&quot;----branch visited: HighTemps>=10!!!, %d degrees more than standart!!!----\n&quot;,
           HighTemps);
    __CrestClearStack(8);
  } else {
    __CrestBranch(6, 10, 0);
#line 14
    printf((char const   * __restrict  )&quot;----branch visited: !(HighTemps>=10)----\n&quot;);
    __CrestClearStack(9);
  }
  __CrestLoad(10, (unsigned long )0, (long long )0);
  __CrestStore(11, (unsigned long )(&amp; __retres2));
#line 16
  __retres2 = 0;
  __CrestLoad(12, (unsigned long )(&amp; __retres2), (long long )__retres2);
  __CrestReturn(13);
#line 8
#line 7

printf(&quot;\ninputs sent by harness: tank1:%d, tank2:%d, drain:%d, solution:%d, warnings:%d\n&quot;, tank1,tank2,drain, solution, Warnings);

__CrestClearStack(0);

__CrestWriteSE();
</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_HIYx4GdjEeiqifykceCvxw" event="_qLyfsGdiEeiqifykceCvxw" port="_GQwmUGdjEeiqifykceCvxw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_5zIWAGgoEeijRtS4FXxxtA" name="t1" source="_bigO0N7GEeiBkYD2qJeUwg" target="_jRLeAGdiEeiqifykceCvxw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_MVmxsGg0EeijRtS4FXxxtA" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>  int __retres4 ;
  __CrestInit();

  __CrestCall(1, 1);
#line 13
  __CrestInt(&amp; desiredLevel);
#line 14
  __CrestInt(&amp; temprature);
  __CrestLoad(4, (unsigned long )(&amp; temprature), (long long )temprature);
  __CrestLoad(3, (unsigned long )0, (long long )60);
  __CrestApply2(2, 17, (long long )(temprature >= 60));
#line 17
  if (temprature >= 60) {
    __CrestBranch(5, 3, 1);
    {
    __CrestLoad(9, (unsigned long )(&amp; desiredLevel), (long long )desiredLevel);
    __CrestLoad(8, (unsigned long )0, (long long )5);
    __CrestApply2(7, 17, (long long )(desiredLevel >= 5));
#line 17
    if (desiredLevel >= 5) {
      __CrestBranch(10, 4, 1);
#line 18
      printf((char const   * __restrict  )&quot;----branch visited: temprature>=60 &amp;&amp; desiredLevel>=5 ----\n&quot;);
      __CrestClearStack(12);
      __CrestLoad(15, (unsigned long )(&amp; temprature), (long long )temprature);
      __CrestLoad(14, (unsigned long )0, (long long )60);
      __CrestApply2(13, 1, (long long )(temprature - 60));
      __CrestStore(16, (unsigned long )(&amp; HighTemps));
#line 19
      HighTemps = temprature - 60;
    } else {
      __CrestBranch(11, 5, 0);
#line 22
      printf((char const   * __restrict  )&quot;----branch visited: !(temprature>=60 &amp;&amp; desiredLevel>=5)----\n&quot;);
      __CrestClearStack(17);
    }
    }
  } else {
    __CrestBranch(6, 6, 0);
#line 22
    printf((char const   * __restrict  )&quot;----branch visited: !(temprature>=60 &amp;&amp; desiredLevel>=5)----\n&quot;);
    __CrestClearStack(18);
  }
  __CrestLoad(19, (unsigned long )0, (long long )0);
  __CrestStore(20, (unsigned long )(&amp; __retres4));
#line 24
  __retres4 = 0;
  __CrestLoad(21, (unsigned long )(&amp; __retres4), (long long )__retres4);
  __CrestReturn(22);
#line 8

printf(&quot;\ninputs sent by harness: desiredLevel:%d, temprature:%d, HighTemps:%d\n&quot;, desiredLevel,temprature,HighTemps);

__CrestClearStack(0);

__CrestWriteSE();
</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_bcGQsGgpEeijRtS4FXxxtA" event="_CXoYoGdjEeiqifykceCvxw" port="_GQwmUGdjEeiqifykceCvxw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_vaGlQIY7EeiKGobklzfqdw" name="reset2" source="_xgSBAGdiEeiqifykceCvxw" target="_jRLeAGdiEeiqifykceCvxw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_sHfQQJK4EeiPG4gJcsWGbA" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>    //restore previously saved global variables 
	//Todo

//cuteCommands.newIteration().send();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_xthZYIY7EeiKGobklzfqdw" event="_a97JIGg4EeijRtS4FXxxtA" port="_ugLW4GgvEeijRtS4FXxxtA"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_doiSwOEtEeiBkYD2qJeUwg" name="reset1" source="_jRLeAGdiEeiqifykceCvxw" target="_bigO0N7GEeiBkYD2qJeUwg">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_y5o44OEtEeiBkYD2qJeUwg" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>    //restore previously saved global variables 
	//Todo

//cuteCommands.newIteration().send();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_mUkOwOEtEeiBkYD2qJeUwg" event="_a97JIGg4EeijRtS4FXxxtA" port="_ugLW4GgvEeijRtS4FXxxtA"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_rczS0ORtEeiwK5UPZ22vmQ" name="" source="_xgSBAGdiEeiqifykceCvxw" target="_bigO0N7GEeiBkYD2qJeUwg">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_HzolgORuEeiwK5UPZ22vmQ" name="Effect" isReentrant="false">
              <language>C++</language>
              <body>//restart global variables
Warnings=0;</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_E422cORuEeiwK5UPZ22vmQ" event="_CveIEORuEeiwK5UPZ22vmQ" port="_ugLW4GgvEeijRtS4FXxxtA"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_jREJQGdiEeiqifykceCvxw"/>
          <subvertex xmi:type="uml:State" xmi:id="_jRLeAGdiEeiqifykceCvxw" name="Setup">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_GEHmgGgpEeijRtS4FXxxtA" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>    //save global variables for future executions
	//Todo

log.log (&quot;@@@@ MUT: Setup---!\n&quot;);

    cuteCommands.newState(SETUP).send();
</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_xgSBAGdiEeiqifykceCvxw" name="Filling">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_G9JgQGgpEeijRtS4FXxxtA" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>    //save global variables for future executions
	//Todo

log.log (&quot;@@@@ MUT: filling---!\n&quot;);
cuteCommands.newState(FILLING).send();</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_bigO0N7GEeiBkYD2qJeUwg" name="Init">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_oGq6AN7GEeiBkYD2qJeUwg" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>    //save global variables for future executions
	//Todo

log.log (&quot;@@@@ MUT: Init---!\n&quot;);

cuteCommands.newState(INIT).send();
</body>
            </entry>
          </subvertex>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_oIUzIGdiEeiqifykceCvxw" name="Protocol1">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_oIRIwGdiEeiqifykceCvxw" name="Protocol1">
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_oIaSsGdiEeiqifykceCvxw" client="_oIRIwGdiEeiqifykceCvxw" supplier="_oIYdgGdiEeiqifykceCvxw" contract="_oIYdgGdiEeiqifykceCvxw"/>
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_oIiOgGdiEeiqifykceCvxw" client="_oIRIwGdiEeiqifykceCvxw" supplier="_oIfyQGdiEeiqifykceCvxw" contract="_oIfyQGdiEeiqifykceCvxw"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_oIYdgGdiEeiqifykceCvxw" name="Protocol1">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_qLwqgGdiEeiqifykceCvxw" name="start">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_1wHYsORMEeitooxfkYAKHg" name="tank1">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_2BmxUORMEeitooxfkYAKHg" name="tank2">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_2ESR4ORMEeitooxfkYAKHg" name="solution">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_2GfRUORMEeitooxfkYAKHg" name="drain">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_CXnKgGdjEeiqifykceCvxw" name="setup">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_CXnKgWdjEeiqifykceCvxw" name="desiredLevel">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_bj2ywH8YEeipA49rzMw2KQ" name="temprature">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_Sr3UsGgqEeijRtS4FXxxtA" name="reset"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_VIXn8H8WEeipA49rzMw2KQ" name="abort"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_aNEQ4H8WEeipA49rzMw2KQ" name="dye"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_b5UXUH8WEeipA49rzMw2KQ" name="drain"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_dCLc0H8WEeipA49rzMw2KQ" name="level">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_qr7vsH8ZEeipA49rzMw2KQ" name="amount">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_oIcu8GdiEeiqifykceCvxw" name="Protocol1~"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_oIekIGdiEeiqifykceCvxw" client="_oIRIwGdiEeiqifykceCvxw" supplier="_oIcu8GdiEeiqifykceCvxw"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_oIfLMGdiEeiqifykceCvxw" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_oIfyQGdiEeiqifykceCvxw" name="Protocol1IO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_oIiOgWdiEeiqifykceCvxw" client="_oIRIwGdiEeiqifykceCvxw" supplier="_oIfyQGdiEeiqifykceCvxw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_qLyfsGdiEeiqifykceCvxw" operation="_qLwqgGdiEeiqifykceCvxw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_CXoYoGdjEeiqifykceCvxw" operation="_CXnKgGdjEeiqifykceCvxw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_Sr6YAGgqEeijRtS4FXxxtA" operation="_Sr3UsGgqEeijRtS4FXxxtA"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_VIaEMH8WEeipA49rzMw2KQ" operation="_VIXn8H8WEeipA49rzMw2KQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_aNGGEH8WEeipA49rzMw2KQ" operation="_aNEQ4H8WEeipA49rzMw2KQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_b5XaoH8WEeipA49rzMw2KQ" operation="_b5UXUH8WEeipA49rzMw2KQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_dCOgIH8WEeipA49rzMw2KQ" operation="_dCLc0H8WEeipA49rzMw2KQ"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_K8YA0GgnEeijRtS4FXxxtA" name="MCUTE">
      <packagedElement xmi:type="uml:Class" xmi:id="_ZSoUsGgnEeijRtS4FXxxtA" name="CUTE_Harness" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_rximYGgvEeijRtS4FXxxtA" name="commands" visibility="public" type="_FiiUsGgvEeijRtS4FXxxtA" isOrdered="true" aggregation="composite" isBehavior="true"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_z-v4YGgvEeijRtS4FXxxtA" name="data" visibility="public" type="_oIRIwGdiEeiqifykceCvxw" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_NjzxkGgxEeijRtS4FXxxtA" name="ActionCodeBranches" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_RAiXIGgxEeijRtS4FXxxtA" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_iqHc8GgxEeijRtS4FXxxtA" name="timingRunning" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_wUrIcGgxEeijRtS4FXxxtA" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_d2aWAGg0EeijRtS4FXxxtA" name="States" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_d2aWAWg0EeijRtS4FXxxtA" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_d84xcGg0EeijRtS4FXxxtA" name="Transitions" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_d84xcWg0EeijRtS4FXxxtA" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_gsG2IGhHEeijRtS4FXxxtA" name="settings" visibility="public" type="_CV8wAWhHEeijRtS4FXxxtA" isOrdered="true" aggregation="composite" isBehavior="true"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_dxTFUH5VEeipA49rzMw2KQ" name="next_t" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_UcsUAH_iEeiMFcUmhpquNg" name="RunningTime" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_UcsUAX_iEeiMFcUmhpquNg" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_2fNpAICkEeib_vS042iOdQ" name="LoopBound" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_2fNpAYCkEeib_vS042iOdQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_rs2nwICmEeib_vS042iOdQ" name="LoopExecutions" visibility="public"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_ErnuUH_qEeiMFcUmhpquNg" name="VisitedBranches" visibility="public"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_rujXUH_qEeiMFcUmhpquNg" name="VisitedTransitions" visibility="public"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_r5SAoH_qEeiMFcUmhpquNg" name="VisitedStates" visibility="public"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_DtF10IVWEeiKGobklzfqdw" name="strategyObj" visibility="public"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_2OVhMKcAEeii3rHGIK9rRQ" name="TExecutions" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_2OVhMacAEeii3rHGIK9rRQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_hLXbQPDOEeiBrOAOs4BT-g" name="ConsecutiveTransitionsExecuted" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_hLXbQfDOEeiBrOAOs4BT-g" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_huc6MPDOEeiBrOAOs4BT-g" name="ConsecutiveTransitionsPromised" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_huc6MfDOEeiBrOAOs4BT-g" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_DU9yIN7ZEeiBkYD2qJeUwg" name="TotalIterationsPromised" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_DU9yId7ZEeiBkYD2qJeUwg" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_DXKxkN7ZEeiBkYD2qJeUwg" name="TotalIterationsExecuted" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_DXKxkd7ZEeiBkYD2qJeUwg" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_Fp9s4OFFEeiBkYD2qJeUwg" name="Curr_State" visibility="public" type="_TEwR0H5PEeipA49rzMw2KQ"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_SkthcOIIEeitsrWbfpHoZQ" name="timingReport" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_hekjgOLKEeiS-ZARNzPJ8Q" name="timingEventConsume" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_88L7sON5EeiS-ZARNzPJ8Q" name="Depth" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_88L7seN5EeiS-ZARNzPJ8Q" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_tP7n8OOqEeiS-ZARNzPJ8Q" name="TransitionIterations" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_tP7n8eOqEeiS-ZARNzPJ8Q" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_Kq0FEOjvEeidvedyZ74wtA" name="TransitionIterationsExecuted" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_Kq0FEejvEeidvedyZ74wtA" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_9AkscON5EeiS-ZARNzPJ8Q" name="Constraints" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_9AksceN5EeiS-ZARNzPJ8Q" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_8ciGQOOwEeiS-ZARNzPJ8Q" name="timingReadFile" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_uS3LgOaSEeiwK5UPZ22vmQ" name="timingRunningId" visibility="public">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_XiTHgOk0EeiYVL3mrKgfUA" name="timingForceTransitionId" visibility="public">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_KvXXoOavEeiwK5UPZ22vmQ" name="CoverageUtilObjs" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_cQpboPD4EeiEK7ZB4QGZMA" name="timingBFSId" visibility="public">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_-LTfMO93EeiBrOAOs4BT-g" name="CoverageUtilTable" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_ymrygObREeiwK5UPZ22vmQ" name="Terminated" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_ymrygebREeiwK5UPZ22vmQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_55OVcOhlEeidvedyZ74wtA" name="Strategy" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_eBp2kOjyEeidvedyZ74wtA" name="timingRandomIteration" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_GQg2oOk0EeiYVL3mrKgfUA" name="timingForceTransition" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="__XlrAOm3EeiYVL3mrKgfUA" name="TestStartTime" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:OpaqueExpression" xmi:id="_aZqxQOm4EeiYVL3mrKgfUA">
            <language>C++</language>
            <body>time(NULL)</body>
          </defaultValue>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_nxRLgPC-EeiBrOAOs4BT-g" name="timingBFSNextMsg" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_FrDiEGgwEeijRtS4FXxxtA" name="StateMachineCuteHarness" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_FrHMcGgwEeijRtS4FXxxtA" name="Region">
            <transition xmi:type="uml:Transition" xmi:id="_FrNTEWgwEeijRtS4FXxxtA" name="" source="_2YhyQH_gEeiMFcUmhpquNg" target="_Sy9EkOhlEeidvedyZ74wtA">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_YtFSUG6jEeisYt_0zxy50Q" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>RunningTime = execTime;
Strategy=strategy;
TransitionIterations = transitionIterations;
if (totalIterations>0) {
	TotalIterationsPromised = totalIterations;
}
TotalIterationsExecuted=0;
log.log(&quot;\n------------------------------------------\n&quot;);
log.log (&quot;Running MCUTE with the following settings:\n&quot;);
log.log(&quot;Strategy = %s, Execution time = %d, Transition Iterations = %d, Total Iterations (for all transitions)= %d \n&quot;, strategy, RunningTime, TransitionIterations, TotalIterationsPromised);
log.log(&quot;------------------------------------------\n&quot;);
//all states, transition, branches are set statically
States=3;
Transitions=2;
ActionCodeBranches=6;
//loop execution default values for all transitions with loop
//LoopExecutions[T2]=0;
//strategy = new crest::RandomSearch(&quot;&quot;, 1);
//    umlCUTE cute;
//   cute.addXXX(100,200);
//end
if (RunningTime>0) {
	timingRunningId = timingRunning.informIn(UMLRTTimespec(RunningTime,0));

}else
{
   timingRunningId = timingRunning.informIn(UMLRTTimespec(4,0));
}
//for random numbers
srand (time(NULL));
next_t=&quot;t1&quot;;
Curr_State=INIT;



</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_wdhG0GmvEeiLpMcT--nfLg" event="_JglVQGhIEeijRtS4FXxxtA" port="_gsG2IGhHEeijRtS4FXxxtA"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_VmZH8GgxEeijRtS4FXxxtA" name="Max_Reached" guard="_Icn2kKcBEeii3rHGIK9rRQ" source="_cBWz0KPHEeii3rHGIK9rRQ" target="_vFIAMOIDEeitsrWbfpHoZQ">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_Icn2kKcBEeii3rHGIK9rRQ">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_IcpEsKcBEeii3rHGIK9rRQ">
                  <language>C++</language>
                  <body>//whether or not the search budget is over, or whether or not all the transitions were already visited
return TotalIterationsPromised > 0 &amp;&amp; TotalIterationsExecuted >= TotalIterationsPromised 
|| (find(VisitedTransitions.begin(), VisitedTransitions.end(), &quot;t1&quot;)!=VisitedTransitions.end() &amp;&amp; 
   find(VisitedTransitions.begin(), VisitedTransitions.end(), &quot;t2&quot;)!=VisitedTransitions.end() );
</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_b17OIOIIEeitsrWbfpHoZQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>timingReport.informIn(UMLRTTimespec(1,1));
log.log(&quot;-- choice2, false --\n&quot;);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_EuVzoH5UEeipA49rzMw2KQ" name="Exec_New_Transition_Or_Max_Reached" source="_KNFQkOE2EeiBkYD2qJeUwg" target="_cBWz0KPHEeii3rHGIK9rRQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_pvU34OO-EeitooxfkYAKHg" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>log.log(&quot;-- choice2 --\n&quot;);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_6UmmQH_gEeiMFcUmhpquNg" source="_FrJBoGgwEeijRtS4FXxxtA" target="_ayVIUORnEeiwK5UPZ22vmQ"/>
            <transition xmi:type="uml:Transition" xmi:id="_EKmcYLq4Eeii3rHGIK9rRQ" name="" source="_FrLd4GgwEeijRtS4FXxxtA" target="_UtmewGgxEeijRtS4FXxxtA">
              <trigger xmi:type="uml:Trigger" xmi:id="_M4JbULq4Eeii3rHGIK9rRQ" port="_iqHc8GgxEeijRtS4FXxxtA">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_bKhdgOIEEeitsrWbfpHoZQ" name="" source="_vFIAMOIDEeitsrWbfpHoZQ" target="_vFIAMOIDEeitsrWbfpHoZQ">
              <trigger xmi:type="uml:Trigger" xmi:id="_cNk18OIEEeitsrWbfpHoZQ" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_N0aikOIFEeitsrWbfpHoZQ" event="_YilhYGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_Z5qdIOIFEeitsrWbfpHoZQ" event="_KK5UsOE1EeiBkYD2qJeUwg" port="_rximYGgvEeijRtS4FXxxtA"/>
              <trigger xmi:type="uml:Trigger" xmi:id="_au5cAOIFEeitsrWbfpHoZQ" event="_OdRbEGgvEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_YNquAOIIEeitsrWbfpHoZQ" name="" source="_vFIAMOIDEeitsrWbfpHoZQ" target="_UtmewGgxEeijRtS4FXxxtA">
              <trigger xmi:type="uml:Trigger" xmi:id="_clPyQOIIEeitsrWbfpHoZQ" port="_SkthcOIIEeitsrWbfpHoZQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_Qfeu0OO_EeitooxfkYAKHg" name="Selecting_Next_Transition" source="_cBWz0KPHEeii3rHGIK9rRQ" target="_KIQUUOQ-EeitooxfkYAKHg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_R3aLEOO_EeitooxfkYAKHg" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>log.log(&quot;-- choice2, true --\n&quot;);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_fnsUwORnEeiwK5UPZ22vmQ" name="" source="_ayVIUORnEeiwK5UPZ22vmQ" target="_2YhyQH_gEeiMFcUmhpquNg">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_cTFv8O9pEeiBrOAOs4BT-g" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>
   coverage_util* cu1 = new coverage_util(string(&quot;t1&quot;));
   cu1->initCoverageInfo();

   coverage_util* cu2 = new coverage_util(string(&quot;t2&quot;));
   cu2->initCoverageInfo();

   CoverageUtilTable.insert(pair&lt;string, coverage_util*>(&quot;t1&quot;,cu1));
   CoverageUtilTable.insert(pair&lt;string, coverage_util*>(&quot;t2&quot;,cu2));
</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_oqCfAORnEeiwK5UPZ22vmQ" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_c_M2IOhlEeidvedyZ74wtA" guard="_EHv-8OhmEeidvedyZ74wtA" source="_Sy9EkOhlEeidvedyZ74wtA" target="_ICRTwOhmEeidvedyZ74wtA">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_EHv-8OhmEeidvedyZ74wtA">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_EHwmAOhmEeidvedyZ74wtA">
                  <language>C++</language>
                  <body>//return Strategy==&quot;RND&quot; || Strategy==&quot;RANDOM&quot; || Strategy==&quot;R&quot;;
return Strategy==&quot;SMP&quot; || Strategy==&quot;smp&quot; || Strategy==&quot;simple&quot; || Strategy==&quot;SIMPLE&quot; || Strategy==&quot;S&quot; || Strategy==&quot;s&quot;;</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_dOMxYPDqEeiBrOAOs4BT-g" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>//writing strategy to a file
fileutil::writeData(&quot;strategy&quot;, &quot;0&quot;);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_etJlsOhlEeidvedyZ74wtA" guard="_DFvvYOhmEeidvedyZ74wtA" source="_Sy9EkOhlEeidvedyZ74wtA" target="_KIQUUOQ-EeitooxfkYAKHg">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_DFvvYOhmEeidvedyZ74wtA">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_DFvvYehmEeidvedyZ74wtA">
                  <language>C++</language>
                  <body>return Strategy==&quot;DFS&quot; || Strategy==&quot;D&quot;;</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_d7ulwPDqEeiBrOAOs4BT-g" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>//writing strategy to a file
fileutil::writeData(&quot;strategy&quot;, &quot;1&quot;);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_nAZ1UOhlEeidvedyZ74wtA" name="" source="_5u_Q0OhkEeidvedyZ74wtA" target="_UtmewGgxEeijRtS4FXxxtA">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_k3dfsOkREeiYDrXBQFB6pw" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>log.log (&quot;\n---- test execution timeout-----\n&quot;);</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_oOh1UOhlEeidvedyZ74wtA" port="_iqHc8GgxEeijRtS4FXxxtA">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_NIpDUOj4EeiYDrXBQFB6pw" name="Max_Transition_Exec_Reached" source="_hxFjcOj3EeiYDrXBQFB6pw" target="_UtmewGgxEeijRtS4FXxxtA">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_rlDm0OkWEeiYDrXBQFB6pw" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>//cancel the other timer
timingRunning.cancelTimer(timingRunningId);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_EeB28O93EeiBrOAOs4BT-g" guard="_4csWkO93EeiBrOAOs4BT-g" source="_Sy9EkOhlEeidvedyZ74wtA" target="_agpkIO94EeiBrOAOs4BT-g">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_4csWkO93EeiBrOAOs4BT-g">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_4csWke93EeiBrOAOs4BT-g">
                  <language>C++</language>
                  <body>return Strategy==&quot;bfs&quot; || Strategy==&quot;BFS&quot; || Strategy==&quot;B&quot;;</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_bZVhgPDqEeiBrOAOs4BT-g" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>//writing strategy to a file
fileutil::writeData(&quot;strategy&quot;, &quot;2&quot;);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_DiDK0PC_EeiBrOAOs4BT-g" name="" source="_U0eEcO94EeiBrOAOs4BT-g" target="_UtmewGgxEeijRtS4FXxxtA">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_p7vSoPD4EeiEK7ZB4QGZMA" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>timingBFSNextMsg.cancelTimer(timingBFSId);</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_0gzHcPDlEeiBrOAOs4BT-g" port="_iqHc8GgxEeijRtS4FXxxtA">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_JS9TgPEBEeiEK7ZB4QGZMA" name="Collect_Extra_Events_No_Chance_Exec" source="_UtmewGgxEeijRtS4FXxxtA" target="_HpmwEPEBEeiEK7ZB4QGZMA">
              <trigger xmi:type="uml:Trigger" xmi:id="_K4AlwPEBEeiEK7ZB4QGZMA" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_FrJBoGgwEeijRtS4FXxxtA"/>
            <subvertex xmi:type="uml:State" xmi:id="_FrLd4GgwEeijRtS4FXxxtA" name="Concolic___DFS__Testing">
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_KNFQkOE2EeiBkYD2qJeUwg" kind="exitPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_KIQUUOQ-EeitooxfkYAKHg" kind="entryPoint"/>
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_7OwGsOFOEeitsrWbfpHoZQ" name="SelectCandidateTransition" isReentrant="false">
                <language>C++</language>
                <body>
//*****************************************************************
//**** deciding what is the next transition to be executed ********
//*****************************************************************

log.log (&quot;--- \n Selecting the next transition for execution ----\n&quot;);

//keep track of visited states
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
  VisitedStates.push_back(Curr_State);
}


//Selecting next transition
SelectNextTransition();

//initialize the coverage info object for the transition
//CoverageInfo.transition = next_t;
//coverage_util cu(next_t);
//cu.initCoverageInfo();
//CoverageUtilObjs.push_back(cu);
</body>
              </entry>
              <region xmi:type="uml:Region" xmi:id="_GjyEYGgxEeijRtS4FXxxtA" name="Region1">
                <transition xmi:type="uml:Transition" xmi:id="_LKRRkOE2EeiBkYD2qJeUwg" name="TransitionExecuted [All_Branches_Covered?]" source="_jodUMOE1EeiBkYD2qJeUwg" target="_TIhPoOE4EeiBkYD2qJeUwg">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_16h1AOFDEeiBkYD2qJeUwg" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>TotalIterationsExecuted++;

//update/measure the visited branches
//can we continue the previous transition?

//keep track of visited states
Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	VisitedStates.push_back(Curr_State);
}

if (Curr_State==INIT){
	log.log(&quot;state is INIT&quot;);
}else if (Curr_State==SETUP){
	log.log(&quot;state is SETUP&quot;);
}


//updating the coverage information
SymbolicExecution ex;
std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
ex.Parse(in);
in.close();
//printf (&quot;\n[[vector size=%d]]\n&quot;, CoverageUtilObjs.size());
coverage_util* it = CoverageUtilTable[next_t];
it->incIterations();
it->updateCoverageInfo(ex);

</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_mJ3GsOFFEeiBkYD2qJeUwg" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_awz2sOE4EeiBkYD2qJeUwg" name="YES_Exec_Next_Transition" guard="_smS3QOO5EeiS-ZARNzPJ8Q" source="_TIhPoOE4EeiBkYD2qJeUwg" target="_KNFQkOE2EeiBkYD2qJeUwg">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_smS3QOO5EeiS-ZARNzPJ8Q">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_smS3QeO5EeiS-ZARNzPJ8Q">
                      <language>C++</language>
                      <body>//return as soon as a transition has been executed the maximum number of iterations
//or the whole state machine has been executed the maximum number of iterations
return ( TotalIterationsPromised > 0 &amp;&amp; TotalIterationsExecuted >= TotalIterationsPromised) || ( Depth &lt; 0 );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_j5VU4OO-EeitooxfkYAKHg" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>log.log(&quot;-- choice1 false --\n&quot;);
</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_cN0AMOE4EeiBkYD2qJeUwg" name="NO__Continue_Executing_Ex_Transition" source="_TIhPoOE4EeiBkYD2qJeUwg" target="_nNdD0OLIEeiS-ZARNzPJ8Q">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_BC4MAOFQEeitsrWbfpHoZQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>log.log(&quot;- choice1 true ---\n&quot;);
//send reset message to execute the previous transition again 
commands.reset().send();
log.log (&quot;++++++Harness: msg 'reset' sent&quot;);</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_s_t9gOFAEeiBkYD2qJeUwg" name="" source="_-97_4ORcEeiwK5UPZ22vmQ" target="_tQgA8OOwEeiS-ZARNzPJ8Q">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_8ISfEOIEEeitsrWbfpHoZQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>TotalIterationsExecuted++;

//ToDo: temp, just for test
// Read the symbolic execution object of the previous execution of the transition
//    SymbolicExecution ex;
//    std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
//    ex.Parse(in);
//    in.close();
//	 DFS(0, 3, ex);

Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
if (Curr_State==INIT){
	log.log(&quot;state is INIT&quot;);
}else if (Curr_State==SETUP){
	log.log(&quot;state is SETUP&quot;);
}

//restarting the transition
commands.reset().send();
log.log (&quot;++++++Harness: msg 'reset' sent&quot;);</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_t-zb8OFAEeiBkYD2qJeUwg" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_sJFQUOLIEeiS-ZARNzPJ8Q" name="" source="_nNdD0OLIEeiS-ZARNzPJ8Q" target="_jodUMOE1EeiBkYD2qJeUwg">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_r_ObwOOvEeiS-ZARNzPJ8Q" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//log.log(&quot;---------------------- new iteration, Depth:%d, Total Iterations Executed: -----------------\n&quot;, Depth, TotalIterationsExecuted);


Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
if (Curr_State==INIT){
	log.log(&quot;state is INIT&quot;);
}else if (Curr_State==SETUP){
	log.log(&quot;state is SETUP&quot;);
}</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_x6WrYOLIEeiS-ZARNzPJ8Q" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_u2yCQOOwEeiS-ZARNzPJ8Q" name="" source="_tQgA8OOwEeiS-ZARNzPJ8Q" target="_jodUMOE1EeiBkYD2qJeUwg">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ZmVuAOOxEeiS-ZARNzPJ8Q" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>SymbolicExecution ex;
std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
ex.Parse(in);
in.close();
Constraints=ex.path().constraints().size();
//number of iterations cannot be more than the number of constraints
//todo: should be fixed later with a better algorithm
//since for now we only negate constraints at most as number of times as the maximum number of constraints
Depth = (TransitionIterations>Constraints?Constraints:TransitionIterations) - 1;


Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
if (Curr_State==INIT){
	log.log(&quot;state is INIT&quot;);
}else if (Curr_State==SETUP){
	log.log(&quot;state is SETUP&quot;);
}

//updating the coverage information
//printf (&quot;\n[[vector size=%d]]\n&quot;, CoverageUtilObjs.size());
coverage_util* it = CoverageUtilTable[next_t];
//coverage_util cu = CoverageUtilObjs.at(CoverageUtilObjs.size()-1);
it->incIterations();
it->updateCoverageInfo(ex);

</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_GyqzoOOxEeiS-ZARNzPJ8Q" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_gkBbEOeREeidvedyZ74wtA" source="_KIQUUOQ-EeitooxfkYAKHg" target="_-97_4ORcEeiwK5UPZ22vmQ"/>
                <subvertex xmi:type="uml:State" xmi:id="_jodUMOE1EeiBkYD2qJeUwg" name="Negate_Solve_Gen_Inp">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_lD0lUOE9EeiBkYD2qJeUwg" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>log.log (&quot;Harness: Negating_Solving_Gen, Depth is: %d&quot;, Depth);
if (Depth>=0){
    //handle iteration
    //0. read the symbolic execution object
    // Read the symbolic execution object of the previous execution of the transition
    SymbolicExecution ex;
    std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
    ex.Parse(in);
    in.close();

    //1. negate and solve the PCs
    //ToDo: how to actually call SolveAtBranch
    vector&lt;value_t> input;
    printf(&quot;number of constraints are: %d&quot;, ex.path().constraints().size());
    //for (size_t i = 0; (i &lt; ex.path().constraints().size()); i++) {
	 //	if (i%2==1)
    printf(&quot;\n---Call SolveAtBranch, Depth: %d&quot;, Depth);
	 SolveAtBranch(ex, Depth, input);
    //}
	 Depth--;
    //print the generated inputs
    std::cout &lt;&lt; &quot;\n-----printing inputs generated by the Concolic engine-------\n&quot;;
    for (size_t i = 0; i &lt; input.size(); i++) {
    	std::cout &lt;&lt; &quot;:&quot; &lt;&lt; input[i] &lt;&lt; std::endl;
    }
    //write the inputs to a file, since SI object is initialized by these inputs
    fileutil::writeInputs(&quot;input&quot;, input);

    //2. send message to the current transition
    if (next_t == &quot;t1&quot;) {
    	data.setup(input[0], input[1]).send();
	log.log (&quot;++++++Harness: msg 'setup' sent&quot;);
    } else if (next_t == &quot;t2&quot;) {
    	data.start(input[0], input[1],input[0], input[1]).send();
	log.log (&quot;++++++Harness: msg 'start' sent&quot;);
    }



}</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_TIhPoOE4EeiBkYD2qJeUwg" kind="choice"/>
                <subvertex xmi:type="uml:State" xmi:id="_nNdD0OLIEeiS-ZARNzPJ8Q" name="Wait4Iteration"/>
                <subvertex xmi:type="uml:State" xmi:id="_P8Yv0ONyEeiS-ZARNzPJ8Q" name="_TMP_DBG_">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_X6U2wONyEeiS-ZARNzPJ8Q" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>// Read the symbolic execution object of the previous execution of the transition
 SymbolicExecution ex;
 std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
 ex.Parse(in);
 in.close();
 DFS(0, 10, ex);</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_tQgA8OOwEeiS-ZARNzPJ8Q" name="Restarting">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_BlAb8OOxEeiS-ZARNzPJ8Q" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>//timingReadFile.informIn(UMLRTTimespec(0.5,0));</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_-97_4ORcEeiwK5UPZ22vmQ" name="GeneratingRandomData">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_AaA8UORdEeiwK5UPZ22vmQ" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>

    //-------------------------------------------------
    //---- generate and send random data --------------
    //---- to the selected transition -----------------
    //-------------------------------------------------
    cout&lt;&lt;&quot;------------------------------------------&quot; &lt;&lt;endl;
    cout&lt;&lt;&quot;--------- executing the transition: &quot; &lt;&lt; next_t &lt;&lt;endl;
    cout&lt;&lt;&quot;------------------------------------------&quot; &lt;&lt;endl;
    //e.g., if next_t = &quot;t1&quot; send msg(X);
    //else send msg(Y);
    int imin = std::numeric_limits&lt;int>::min(); // min int value
    int imax = std::numeric_limits&lt;int>::max(); //max int value
    int inp1 = rand() % imax + imin;
    int inp2 = rand() % imax + imin;
    if (next_t==&quot;t1&quot;){
	log.log (&quot;++++++Harness: msg 'setup' sent&quot;);
    	data.setup(inp1, inp2).send();
    }else if (next_t==&quot;t2&quot;){
	log.log (&quot;++++++Harness: msg 'start' sent&quot;);
    	data.start(inp1,inp2,inp1,inp2).send();
    }



</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_2dGS0O92EeiBrOAOs4BT-g" name="Concolic___DFS__Testing">
                  <region xmi:type="uml:Region" xmi:id="_2dGS1O92EeiBrOAOs4BT-g" name="Region1">
                    <transition xmi:type="uml:Transition" xmi:id="_2dGS5O92EeiBrOAOs4BT-g" name="" source="_2dGS7u92EeiBrOAOs4BT-g" target="_2dGS6O92EeiBrOAOs4BT-g"/>
                    <subvertex xmi:type="uml:State" xmi:id="_2dGS6O92EeiBrOAOs4BT-g" name="Negate_Solve_Gen_Inp">
                      <entry xmi:type="uml:OpaqueBehavior" xmi:id="_2dGS6e92EeiBrOAOs4BT-g" name="Entry" isReentrant="false">
                        <language>C++</language>
                        <body>log.log (&quot;Harness: Negating_Solving_Gen, Depth is: %d&quot;, Depth);
if (Depth>=0){
    //handle iteration
    //0. read the symbolic execution object
    // Read the symbolic execution object of the previous execution of the transition
    SymbolicExecution ex;
    std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
    ex.Parse(in);
    in.close();

    //1. negate and solve the PCs
    //ToDo: how to actually call SolveAtBranch
    vector&lt;value_t> input;
    printf(&quot;number of constraints are: %d&quot;, ex.path().constraints().size());
    //for (size_t i = 0; (i &lt; ex.path().constraints().size()); i++) {
	 //	if (i%2==1)
    printf(&quot;\n---Call SolveAtBranch, Depth: %d&quot;, Depth);
	 SolveAtBranch(ex, Depth, input);
    //}
	 Depth--;
    //print the generated inputs
    std::cout &lt;&lt; &quot;\n-----printing inputs generated by the Concolic engine-------\n&quot;;
    for (size_t i = 0; i &lt; input.size(); i++) {
    	std::cout &lt;&lt; &quot;:&quot; &lt;&lt; input[i] &lt;&lt; std::endl;
    }
    //write the inputs to a file, since SI object is initialized by these inputs
    fileutil::writeInputs(&quot;input&quot;, input);

    //2. send message to the current transition
    if (next_t == &quot;t1&quot;) {
    	data.setup(input[0], input[1]).send();
	log.log (&quot;++++++Harness: msg 'setup' sent&quot;);
    } else if (next_t == &quot;t2&quot;) {
    	data.start(input[0], input[1],input[0], input[1]).send();
	log.log (&quot;++++++Harness: msg 'start' sent&quot;);
    }



}</body>
                      </entry>
                    </subvertex>
                    <subvertex xmi:type="uml:Pseudostate" xmi:id="_2dGS6u92EeiBrOAOs4BT-g" kind="choice"/>
                    <subvertex xmi:type="uml:State" xmi:id="_2dGS6-92EeiBrOAOs4BT-g" name="Wait4Iteration"/>
                    <subvertex xmi:type="uml:State" xmi:id="_2dGS7O92EeiBrOAOs4BT-g" name="_TMP_DBG_">
                      <entry xmi:type="uml:OpaqueBehavior" xmi:id="_2dGS7e92EeiBrOAOs4BT-g" name="Entry" isReentrant="false">
                        <language>C++</language>
                        <body>// Read the symbolic execution object of the previous execution of the transition
 SymbolicExecution ex;
 std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
 ex.Parse(in);
 in.close();
 DFS(0, 10, ex);</body>
                      </entry>
                    </subvertex>
                    <subvertex xmi:type="uml:State" xmi:id="_2dGS7u92EeiBrOAOs4BT-g" name="Restarting">
                      <entry xmi:type="uml:OpaqueBehavior" xmi:id="_2dGS7-92EeiBrOAOs4BT-g" name="Entry" isReentrant="false">
                        <language>C++</language>
                        <body>//timingReadFile.informIn(UMLRTTimespec(0.5,0));</body>
                      </entry>
                    </subvertex>
                    <subvertex xmi:type="uml:State" xmi:id="_2dGS8O92EeiBrOAOs4BT-g" name="GeneratingRandomData">
                      <entry xmi:type="uml:OpaqueBehavior" xmi:id="_2dGS8e92EeiBrOAOs4BT-g" name="Entry" isReentrant="false">
                        <language>C++</language>
                        <body>

    //-------------------------------------------------
    //---- generate and send random data --------------
    //---- to the selected transition -----------------
    //-------------------------------------------------
    cout&lt;&lt;&quot;------------------------------------------&quot; &lt;&lt;endl;
    cout&lt;&lt;&quot;--------- executing the transition: &quot; &lt;&lt; next_t &lt;&lt;endl;
    cout&lt;&lt;&quot;------------------------------------------&quot; &lt;&lt;endl;
    //e.g., if next_t = &quot;t1&quot; send msg(X);
    //else send msg(Y);
    int imin = std::numeric_limits&lt;int>::min(); // min int value
    int imax = std::numeric_limits&lt;int>::max(); //max int value
    int inp1 = rand() % imax + imin;
    int inp2 = rand() % imax + imin;
    if (next_t==&quot;t1&quot;){
	log.log (&quot;++++++Harness: msg 'setup' sent&quot;);
    	data.setup(inp1, inp2).send();
    }else if (next_t==&quot;t2&quot;){
	log.log (&quot;++++++Harness: msg 'start' sent&quot;);
    	data.start(inp1,inp2,inp1,inp2).send();
    }



</body>
                      </entry>
                    </subvertex>
                  </region>
                </subvertex>
              </region>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_UtmewGgxEeijRtS4FXxxtA" name="Reporting">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_ta7UIGgxEeijRtS4FXxxtA" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>//calculating branch coverage
int totalBranches=0;
int totalCovered=0;
map&lt;string, coverage_util*>::iterator it;
for (it=CoverageUtilTable.begin();it!=CoverageUtilTable.end();it++){
	totalBranches+=it->second->branches_.size();
	totalCovered+=it->second->total_num_covered_;
}
log.log(&quot;\n=============== Test execution report ===============&quot;);
log.log(&quot;\n     Total test execution time: %d (seconds)   &quot;, time(NULL) - TestStartTime);
log.log(&quot;\n     Total executed test iterations: %d   &quot;, TotalIterationsExecuted);
log.log(&quot;\n     Total Branch coverage: %d out of %d = %%%.1f   &quot;, totalCovered, totalBranches, (float)totalCovered/totalBranches*100);
log.log(&quot;\n     Transition coverage: %d out of %d = %%%.1f   &quot;, VisitedTransitions.size(), Transitions, (float)VisitedTransitions.size()/Transitions * 100);
log.log(&quot;\n     State coverage: %d out of %d = %%%.1f   &quot;, VisitedStates.size(), States, (float)VisitedStates.size()/States * 100);
log.log(&quot;\n=====================================================&quot;);
</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_2YhyQH_gEeiMFcUmhpquNg" name="Starting"/>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_cBWz0KPHEeii3rHGIK9rRQ" kind="choice"/>
            <subvertex xmi:type="uml:State" xmi:id="_vFIAMOIDEeitsrWbfpHoZQ" name="Wait1Sec">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_7ilKkOaREeiwK5UPZ22vmQ" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>//cancel the other timer
timingRunning.cancelTimer(timingRunningId);</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_ayVIUORnEeiwK5UPZ22vmQ" name="Init"/>
            <subvertex xmi:type="uml:State" xmi:id="_5u_Q0OhkEeidvedyZ74wtA" name="Random__SimEXP__Testing">
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_ICRTwOhmEeidvedyZ74wtA" kind="entryPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_hxFjcOj3EeiYDrXBQFB6pw" kind="exitPoint"/>
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_qs6voOjvEeidvedyZ74wtA" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>//selecting the next transition
SelectNextTransition();

//initialize the coverage info object for the transition
//CoverageInfo.transition = next_t;
//coverage_util cu(next_t);
//cu.initCoverageInfo();
//CoverageUtilObjs.push_back(cu);
</body>
              </entry>
              <region xmi:type="uml:Region" xmi:id="_IBdbcOhmEeidvedyZ74wtA" name="Region1">
                <transition xmi:type="uml:Transition" xmi:id="_KF-38OhmEeidvedyZ74wtA" kind="local" source="_ICRTwOhmEeidvedyZ74wtA" target="_JCv5UOhmEeidvedyZ74wtA">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_SjtT8OjvEeidvedyZ74wtA" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>TransitionIterationsExecuted=0;
TotalIterationsExecuted=0;
TExecutions=0;
log.log(&quot;\nTotalIterationsPromised:%d, TotalIterationsExecuted:%d\n&quot;, TotalIterationsPromised, TransitionIterationsExecuted);</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_OWzz8OhmEeidvedyZ74wtA" name="TransitionExecuted" source="_JCv5UOhmEeidvedyZ74wtA" target="_JYpQ0OhmEeidvedyZ74wtA">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_hihPQOk0EeiYVL3mrKgfUA" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//cancel the timer since the transition was executed
timingForceTransition.cancelTimer(timingForceTransitionId);

TransitionIterationsExecuted++;
TotalIterationsExecuted++;</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_uR_XIOhmEeidvedyZ74wtA" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_O8AywOhmEeidvedyZ74wtA" name="NewIteration" source="_JYpQ0OhmEeidvedyZ74wtA" target="_JCv5UOhmEeidvedyZ74wtA">
                  <trigger xmi:type="uml:Trigger" xmi:id="_wbWQUOhmEeidvedyZ74wtA" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_hxe-UOjyEeidvedyZ74wtA" name="" source="_JYpQ0OhmEeidvedyZ74wtA" target="_evvSUOj3EeiYDrXBQFB6pw">
                  <trigger xmi:type="uml:Trigger" xmi:id="_ihbNgOjyEeidvedyZ74wtA" port="_eBp2kOjyEeidvedyZ74wtA">
                    <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
                  </trigger>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_0DdL8OkVEeiYDrXBQFB6pw" name="Select_Candidate_Transition_for_Execution" source="_evvSUOj3EeiYDrXBQFB6pw" target="_JCv5UOhmEeidvedyZ74wtA">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_0l5KoOkVEeiYDrXBQFB6pw" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>log.log(&quot;\nexecuting next transition: %s\n&quot;, next_t.c_str());

  //selecting the next transition
    if (Curr_State==INIT){
      //it is possible to run t1
      next_t = &quot;t1&quot;;
      VisitedTransitions.push_back(next_t);
      log.log (&quot;Curr state: INIT&quot;);
    }else if (Curr_State==SETUP){
      //it is possible to run t2
      next_t = &quot;t2&quot;;
      VisitedTransitions.push_back(next_t);
      log.log (&quot;Curr state: SETUP&quot;);
    }
    else{
      log.log (&quot;Curr state: last state. Restarting..&quot;);
      commands.iterate().send(); //to be able to re-execute the previous transitions
      log.log (&quot;++++++Harness: msg 'loopBack' sent&quot;);
      Curr_State=INIT;
      next_t = &quot;t1&quot;;
    }

    //initialize the coverage info object for the transition
    //CoverageInfo.transition = next_t;
//    coverage_util cu(next_t);
//    cu.initCoverageInfo();
//    CoverageUtilObjs.push_back(cu);</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_3nFqwOkVEeiYDrXBQFB6pw" guard="_4hKtYOkVEeiYDrXBQFB6pw" source="_evvSUOj3EeiYDrXBQFB6pw" target="_hxFjcOj3EeiYDrXBQFB6pw">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_4hKtYOkVEeiYDrXBQFB6pw">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_4hLUcOkVEeiYDrXBQFB6pw">
                      <language>C++</language>
                      <body>//whether or not the search budget is over, or whether or not all the transitions were already visited
return (TotalIterationsPromised > 0 &amp;&amp; TotalIterationsExecuted >= TotalIterationsPromised) 
|| (find(VisitedTransitions.begin(), VisitedTransitions.end(), &quot;t1&quot;)!=VisitedTransitions.end() &amp;&amp; 
   find(VisitedTransitions.begin(), VisitedTransitions.end(), &quot;t2&quot;)!=VisitedTransitions.end() );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_4vwjAOkVEeiYDrXBQFB6pw" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>log.log(&quot;\nenough transitions were executed\n&quot;);</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_wGDmoOkzEeiYVL3mrKgfUA" name="Keep_Sending_New_Msgs_To_Force_Exec" source="_JCv5UOhmEeidvedyZ74wtA" target="_JYpQ0OhmEeidvedyZ74wtA">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_J4A24Ok2EeiYVL3mrKgfUA" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>log.log (&quot;transition [%s] was not fired since its gaurd predicate did not hold. Trying again..&quot;, next_t.c_str());</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_Jx22cOk0EeiYVL3mrKgfUA" port="_GQg2oOk0EeiYVL3mrKgfUA">
                    <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
                  </trigger>
                </transition>
                <subvertex xmi:type="uml:State" xmi:id="_JCv5UOhmEeidvedyZ74wtA" name="SendMessage">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_BnQisOhnEeidvedyZ74wtA" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>//generating data
//int imin = std::numeric_limits&lt;int>::min(); // min int value
//int imax = std::numeric_limits&lt;int>::max(); //max int value
//TODO: fix this to generate numbers between ranges uniforly using a c++ library
//int inp1 = rand() % imax + imin;
int inp1 = rand() % 300000 + (-100000);
int inp2 = rand() % 300000 + (-100000);
int inp3 = rand() % 300000 + (-100000);
int inp4 = rand() % 300000 + (-100000);
printf(&quot;\ninputs generated by the harness (in random inp gen): %d, %d, %d, %d\n&quot;,inp1,inp2,inp3,inp4 );
vector&lt;value_t> inputs;
inputs.push_back(inp1);
inputs.push_back(inp2);
inputs.push_back(inp3);
inputs.push_back(inp4);

//saving to a file so the action code can restore them from there
fileutil::writeInputs(&quot;input&quot;, inputs);

//send message to the current transition
if (next_t == &quot;t1&quot;) {
  data.setup(0, 0).send();
  log.log (&quot;++++++Harness: msg 'setup' sent&quot;);
} else if (next_t == &quot;t2&quot;) {
  data.start(0, 0, 0, 0).send();
  log.log (&quot;++++++Harness: msg 'start' sent&quot;);
}

//TODO: pursue this issue
//if the transition is not executed normally, retart to send a new message in the next iteration
//timingForceTransitionId = timingForceTransition.informIn(UMLRTTimespec(0.2,0));
</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_JYpQ0OhmEeidvedyZ74wtA" name="Prepare4NextIteration">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_6hrnIOhmEeidvedyZ74wtA" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>//keep track of visited states
if (rtdata){
	Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
	if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	  VisitedStates.push_back(Curr_State);
	}
}
//reading SE object
SymbolicExecution ex;
std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
ex.Parse(in);
in.close();

//updating the coverage information
//printf (&quot;\n[[vector size=%d]]\n&quot;, CoverageUtilObjs.size());
coverage_util* it = CoverageUtilTable[next_t];
it->incIterations();
it->updateCoverageInfo(ex);


if (TransitionIterationsExecuted&lt;TransitionIterations)
{
  //restarting
  commands.reset().send();
}else{
  //go back to previous state to be able to send new inputs
  if (TExecutions&lt;Transitions){
    log.log(&quot;\nchanging the transition\n&quot;);
    TExecutions++;
    
    timingRandomIteration.informIn(UMLRTTimespec(0,100));
    TransitionIterationsExecuted=0;
  }
}
</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_evvSUOj3EeiYDrXBQFB6pw" kind="choice"/>
              </region>
            </subvertex>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_Sy9EkOhlEeidvedyZ74wtA" kind="choice"/>
            <subvertex xmi:type="uml:State" xmi:id="_U0eEcO94EeiBrOAOs4BT-g" name="Concolic___BFS__Testing">
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_agpkIO94EeiBrOAOs4BT-g" kind="entryPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_ATKM8PC_EeiBrOAOs4BT-g" kind="exitPoint"/>
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WaJo0O94EeiBrOAOs4BT-g" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>
//*****************************************************************
//**** deciding what is the next transition to be executed ********
//*****************************************************************

log.log (&quot;--- \n Selecting the next transition for execution ----\n&quot;);

//keep track of visited states
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
  VisitedStates.push_back(Curr_State);
}


//Selecting next transition
SelectNextTransition();

</body>
              </entry>
              <region xmi:type="uml:Region" xmi:id="_aggaMO94EeiBrOAOs4BT-g" name="Region1">
                <transition xmi:type="uml:Transition" xmi:id="_cPmZQO94EeiBrOAOs4BT-g" kind="local" source="_agpkIO94EeiBrOAOs4BT-g" target="_bXr50O94EeiBrOAOs4BT-g">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_cXhHMPDNEeiBrOAOs4BT-g" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>ConsecutiveTransitionsPromised=2;
ConsecutiveTransitionsExecuted=0;
TotalIterationsExecuted=0;
Depth=0;</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_u0yRkPC-EeiBrOAOs4BT-g" name="Transition_Executed" source="_bXr50O94EeiBrOAOs4BT-g" target="_sO50cPC-EeiBrOAOs4BT-g">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_d8mcYPDSEeiBrOAOs4BT-g" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//keep track of visited states
Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	VisitedStates.push_back(Curr_State);
}

ConsecutiveTransitionsExecuted++;
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_wGDsMPC-EeiBrOAOs4BT-g" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_yGtVUPC-EeiBrOAOs4BT-g" name="timeout/Execute_Next_Transition" source="_sO50cPC-EeiBrOAOs4BT-g" target="_bXr50O94EeiBrOAOs4BT-g">
                  <trigger xmi:type="uml:Trigger" xmi:id="_1aMfUPC-EeiBrOAOs4BT-g" port="_nxRLgPC-EeiBrOAOs4BT-g">
                    <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
                  </trigger>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_5c_J4PC_EeiBrOAOs4BT-g" name="nextState/updateCoverage" source="_z4x6cPC_EeiBrOAOs4BT-g" target="_bXr50O94EeiBrOAOs4BT-g">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_s0HvcPDAEeiBrOAOs4BT-g" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//keep track of visited states
Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	VisitedStates.push_back(Curr_State);
}

ConsecutiveTransitionsExecuted++;

SelectNextTransition();

SymbolicExecution ex;
std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
ex.Parse(in);
in.close();
Constraints=ex.path().constraints().size();
//number of iterations cannot be more than the number of constraints
//todo: should be fixed later with a better algorithm
//since for now we only negate constraints at most as number of times as the maximum number of constraints
Depth = (TransitionIterations>Constraints?Constraints:TransitionIterations) - 1;


Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
if (Curr_State==INIT){
  log.log(&quot;state is INIT&quot;);
}else if (Curr_State==SETUP){
  log.log(&quot;state is SETUP&quot;);
}

//updating the coverage information
printf (&quot;\n[[vector size=%d]]\n&quot;, CoverageUtilTable.size());
coverage_util* it = CoverageUtilTable[next_t];
it->incIterations();
it->updateCoverageInfo(ex);
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_6jgGAPC_EeiBrOAOs4BT-g" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_XRIKQPDPEeiBrOAOs4BT-g" name="New_Iteration_Initiated/Negate_Solve_Constraint" guard="_f72asPD7EeiEK7ZB4QGZMA" source="_-5mhwPD6EeiEK7ZB4QGZMA" target="_bXr50O94EeiBrOAOs4BT-g">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_f72asPD7EeiEK7ZB4QGZMA">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_f74P4PD7EeiEK7ZB4QGZMA">
                      <language>C++</language>
                      <body>return (TotalIterationsExecuted &lt; TotalIterationsPromised) &amp;&amp; !AllBranchesCovered();</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_uko1kPDmEeiBrOAOs4BT-g" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//keep track of visited states
Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	VisitedStates.push_back(Curr_State);
}
SelectNextTransition();


log.log (&quot;Harness: Negating_Solving_Gen, Depth is: %d&quot;, Depth);
if (Depth&lt;Constraints){
  //handle iteration
  //0. read the symbolic execution object
  // Read the symbolic execution object of the previous execution of the transition
  SymbolicExecution ex;
  std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
  ex.Parse(in);
  in.close();
  
  //1. negate and solve the PCs
  //ToDo: how to actually call SolveAtBranch
  vector&lt;value_t> input;
  printf(&quot;number of constraints are: %d&quot;, ex.path().constraints().size());
  //for (size_t i = 0; (i &lt; ex.path().constraints().size()); i++) {
  //	if (i%2==1)
  printf(&quot;\n---Call SolveAtBranch, Depth: %d&quot;, Depth);
  SolveAtBranch(ex, Depth, input);
  //}
  Depth++;
  //print the generated inputs
  std::cout &lt;&lt; &quot;\n-----printing inputs generated by the Concolic engine-------\n&quot;;
  for (size_t i = 0; i &lt; input.size(); i++) {
    std::cout &lt;&lt; &quot;:&quot; &lt;&lt; input[i] &lt;&lt; std::endl;
  }
  //write the inputs to a file, since SI object is initialized by these inputs
  fileutil::writeInputs(&quot;input&quot;, input);
}else{
Depth=0;
}</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_JyglAPD7EeiEK7ZB4QGZMA" name="" source="_sO50cPC-EeiBrOAOs4BT-g" target="_-5mhwPD6EeiEK7ZB4QGZMA">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_ZVz60PD7EeiEK7ZB4QGZMA" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>TotalIterationsExecuted++;
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_KgaM0PD7EeiEK7ZB4QGZMA" event="_YYw3AGgzEeijRtS4FXxxtA" port="_rximYGgvEeijRtS4FXxxtA"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_Ok_ckPD7EeiEK7ZB4QGZMA" source="_-5mhwPD6EeiEK7ZB4QGZMA" target="_ATKM8PC_EeiBrOAOs4BT-g"/>
                <subvertex xmi:type="uml:State" xmi:id="_bXr50O94EeiBrOAOs4BT-g" name="MsgSending">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_eptEMO94EeiBrOAOs4BT-g" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>
  
  //2. send message to the current transition
  if (next_t == &quot;t1&quot;) {
    data.setup(0, 0).send();
    log.log (&quot;++++++Harness: msg 'setup' sent&quot;);
  } else if (next_t == &quot;t2&quot;) {
    data.start(0, 0, 0, 0).send();
    log.log (&quot;++++++Harness: msg 'start' sent&quot;);
  }

cout &lt;&lt;endl&lt;&lt; &quot;================================================================================&quot; &lt;&lt;endl;
cout &lt;&lt; &quot;\t\t\tExecuting the transition: &quot; &lt;&lt; next_t.c_str() &lt;&lt; endl;
cout &lt;&lt; &quot;================================================================================&quot; &lt;&lt;endl&lt;&lt;endl;

</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_sO50cPC-EeiBrOAOs4BT-g" name="MsgRecieved">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_vTXl0PDQEeiBrOAOs4BT-g" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>//reading SE object
SymbolicExecution ex;
std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
ex.Parse(in);
in.close();

cout &lt;&lt; &quot;\nNumber of constraints: &quot; &lt;&lt; ex.path().constraints().size() &lt;&lt; endl;
Constraints = ex.path().constraints().size()-1;

//print SE object info
fileutil::printSymExObj(false, true, false);

//updating the coverage information
coverage_util* it = CoverageUtilTable[next_t];
it->incIterations();
it->updateCoverageInfo(ex);


//new iteration
if (ConsecutiveTransitionsExecuted>=ConsecutiveTransitionsPromised){
  log.log(&quot;\nnew iteration,restarting\n&quot;);
  commands.iterate().send();
  ConsecutiveTransitionsExecuted=0;
  // TExecutions=0;
}
else{
  // TExecutions++;
  //next message by the Harness
	timingBFSId = timingBFSNextMsg.informIn(UMLRTTimespec(0,100));
}

SelectNextTransition();
</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_z4x6cPC_EeiBrOAOs4BT-g" name="InitialMsgSent">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_z4x6cfC_EeiBrOAOs4BT-g" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>

//-------------------------------------------------
//---- generate and send random data --------------
//---- to the selected transition -----------------
//-------------------------------------------------
cout&lt;&lt;&quot;------------------------------------------&quot; &lt;&lt;endl;
cout&lt;&lt;&quot;--------- executing the transition: &quot; &lt;&lt; next_t &lt;&lt;endl;
cout&lt;&lt;&quot;------------------------------------------&quot; &lt;&lt;endl;
//e.g., if next_t = &quot;t1&quot; send msg(X);
//else send msg(Y);
int imin = std::numeric_limits&lt;int>::min(); // min int value
int imax = std::numeric_limits&lt;int>::max(); //max int value
int inp1 = rand() % imax + imin;
int inp2 = rand() % imax + imin;
if (next_t==&quot;t1&quot;){
  log.log (&quot;++++++Harness: msg 'setup' sent&quot;);
  data.setup(inp1, inp2).send();
}else if (next_t==&quot;t2&quot;){
  log.log (&quot;++++++Harness: msg 'start' sent&quot;);
  data.start(inp1,inp2,inp1,inp2).send();
}



</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_-5mhwPD6EeiEK7ZB4QGZMA" kind="choice"/>
              </region>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_HpmwEPEBEeiEK7ZB4QGZMA" name="Done"/>
          </region>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_XROgkOLcEeiS-ZARNzPJ8Q" name="DFSOpaqueBehavior" specification="_TelVYOLcEeiS-ZARNzPJ8Q">
          <language>C++</language>
          <body>std::cout&lt;&lt;&quot;DFS CALLED, depth:&quot;&lt;&lt;depth&lt;&lt;std::endl;
/* UMLRTGEN-USERREGION-BEGIN platform:/resource/MCUTE/Harness_UMLRT/Harness2.uml mCUTE::CUTE_Harness operation DFS */
SymbolicExecution cur_ex;
vector&lt;value_t> input;
const SymbolicPath&amp; path = prev_ex.path();
for (size_t i = pos; (i &lt; path.constraints().size()) &amp;&amp; (depth > 0); i++) {
	// Solve constraints[0..i].
	if (!SolveAtBranch(prev_ex, i, input)) {
		std::cout&lt;&lt;&quot;could not solve depth: &quot;&lt;&lt;i&lt;&lt;std::endl;
		continue;
	}
	// Run on those constraints.
	data.setup(0,0).send();
	commands.reset().send();
	//read the SE object after transition execution
	std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
	cur_ex.Parse(in);
	in.close();
	//UpdateCoverage(cur_ex);
	// We successfully solved the branch, recurse.
	depth--;
	DFS(i+1, depth, cur_ex);
}</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_lysHIOHlEeitsrWbfpHoZQ" name="SolveAtBranchOpaqueBehavior" specification="_Y1TDoOHlEeitsrWbfpHoZQ">
          <language>C++</language>
          <body>const vector&lt;SymbolicPred*>&amp; constraints = ex.path().constraints();

	// Optimization: If any of the previous constraints are idential to the
	// branch_idx-th constraint, immediately return false.
	for (int i = static_cast&lt;int>(branch_idx) - 1; i >= 0; i--) {
		if (constraints[branch_idx]->Equal(*constraints[i]))
			return false;
	}

	vector&lt;const SymbolicPred*> cs(constraints.begin(),
			constraints.begin() + branch_idx + 1);
	map&lt;var_t, value_t> soln;
	constraints[branch_idx]->Negate();
	// fprintf(stderr, &quot;Yices . . . &quot;);
	bool success = YicesSolver::IncrementalSolve(ex.inputs(), ex.vars(), cs,
			&amp;soln);
	// fprintf(stderr, &quot;%d\n&quot;, success);
	constraints[branch_idx]->Negate();

	if (success) {
		// Merge the solution with the previous input to get the next
		// input.  (Could merge with random inputs, instead.)
		input = ex.inputs();
		// RandomInput(ex.vars(), input);

		typedef map&lt;var_t, value_t>::const_iterator SolnIt;
		for (SolnIt i = soln.begin(); i != soln.end(); ++i) {
			input[i->first] = i->second;
		}
		return true;
	}

	return false;
</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_FRWKUOnREeiYVL3mrKgfUA" name="SelectNextTransitionOpaqueBehavior" specification="__6ZTwOnQEeiYVL3mrKgfUA">
          <language>C++</language>
          <body>if (Curr_State==INIT){
  //it is possible to run t1
  next_t = &quot;t1&quot;;
  log.log (&quot;Curr state: INIT&quot;);
}else if (Curr_State==SETUP){
  //it is possible to run t2
  next_t = &quot;t2&quot;;
  log.log (&quot;Curr state: SETUP&quot;);
}
else{
  log.log (&quot;Curr state: last state. Restarting..&quot;);
  //commands.loopBack().send(); //to be able to re-execute the previous transitions
  //log.log (&quot;++++++Harness: msg 'loopBack' sent&quot;);
  Curr_State=INIT;
  next_t = &quot;t1&quot;;
}

//adding the transition to the list of covered transitions
if(std::find(VisitedTransitions.begin(), VisitedTransitions.end(), next_t) == VisitedTransitions.end()){
  VisitedTransitions.push_back(next_t);
}
</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_GLA_QPEOEeiEK7ZB4QGZMA" name="AllBranchesCoveredOpaqueBehavior" specification="_us69IPENEeiEK7ZB4QGZMA">
          <language>C++</language>
          <body>map&lt;string, coverage_util*>::iterator it;
bool allCoverred=true;
for (it=CoverageUtilTable.begin();it!=CoverageUtilTable.end();it++){
  if (it->second->total_num_covered_&lt;it->second->branches_.size()){
    allCoverred=false;
  }
}
return allCoverred;</body>
        </ownedBehavior>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_us69IPENEeiEK7ZB4QGZMA" name="AllBranchesCovered" concurrency="guarded" method="_GLA_QPEOEeiEK7ZB4QGZMA">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_f9qd8PEOEeiEK7ZB4QGZMA" name="allCovered" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_Y1TDoOHlEeitsrWbfpHoZQ" name="SolveAtBranch" concurrency="guarded" method="_lysHIOHlEeitsrWbfpHoZQ">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_uBd-EOHzEeitsrWbfpHoZQ" name="result" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_g5xMYOIREeitsrWbfpHoZQ" name="ex">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_hydu8OIREeitsrWbfpHoZQ" name="branch_idx">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_h2-bgOIREeitsrWbfpHoZQ" name="input">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_TelVYOLcEeiS-ZARNzPJ8Q" name="DFS" concurrency="guarded" method="_XROgkOLcEeiS-ZARNzPJ8Q">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_lTceIOLcEeiS-ZARNzPJ8Q" name="pos">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_l_wxkOLcEeiS-ZARNzPJ8Q" name="depth">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_mCNBkOLcEeiS-ZARNzPJ8Q" name="prev_ex">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="__6ZTwOnQEeiYVL3mrKgfUA" name="SelectNextTransition" concurrency="guarded" method="_FRWKUOnREeiYVL3mrKgfUA"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_FivJAGgvEeijRtS4FXxxtA" name="CUTE_Commands">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_FiiUsGgvEeijRtS4FXxxtA" name="CUTE_Commands">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_Fi0okGgvEeijRtS4FXxxtA" client="_FiiUsGgvEeijRtS4FXxxtA" supplier="_FiyMUGgvEeijRtS4FXxxtA" contract="_FiyMUGgvEeijRtS4FXxxtA"/>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_Fi9LcGgvEeijRtS4FXxxtA" client="_FiiUsGgvEeijRtS4FXxxtA" supplier="_Fi6vMGgvEeijRtS4FXxxtA" contract="_Fi6vMGgvEeijRtS4FXxxtA"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_FiyMUGgvEeijRtS4FXxxtA" name="CUTE_Commands">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_OdOXwGgvEeijRtS4FXxxtA" name="newBranch">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_Pgb7wH_qEeiMFcUmhpquNg" name="branch_name">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_YYvo4GgzEeijRtS4FXxxtA" name="newState">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_vwVpUH5LEeipA49rzMw2KQ" name="state_name">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_Yik6UGgzEeijRtS4FXxxtA" name="newTransition">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_RHk4sH_qEeiMFcUmhpquNg" name="transition_name">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_KK4GkOE1EeiBkYD2qJeUwg" name="newIteration"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_Fi3r4GgvEeijRtS4FXxxtA" name="CUTE_Commands~">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_a9H34Gg4EeijRtS4FXxxtA" name="reset"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_Cvc58ORuEeiwK5UPZ22vmQ" name="iterate"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_Fi5hEGgvEeijRtS4FXxxtA" client="_FiiUsGgvEeijRtS4FXxxtA" supplier="_Fi3r4GgvEeijRtS4FXxxtA"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_Fi6IIGgvEeijRtS4FXxxtA" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_Fi6vMGgvEeijRtS4FXxxtA" name="CUTE_CommandsIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_Fi9ygGgvEeijRtS4FXxxtA" client="_FiiUsGgvEeijRtS4FXxxtA" supplier="_Fi6vMGgvEeijRtS4FXxxtA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_OdRbEGgvEeijRtS4FXxxtA" operation="_OdOXwGgvEeijRtS4FXxxtA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_YYw3AGgzEeijRtS4FXxxtA" operation="_YYvo4GgzEeijRtS4FXxxtA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_YilhYGgzEeijRtS4FXxxtA" operation="_Yik6UGgzEeijRtS4FXxxtA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_a97JIGg4EeijRtS4FXxxtA" operation="_a9H34Gg4EeijRtS4FXxxtA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_KK5UsOE1EeiBkYD2qJeUwg" operation="_KK4GkOE1EeiBkYD2qJeUwg"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_CveIEORuEeiwK5UPZ22vmQ" operation="_Cvc58ORuEeiwK5UPZ22vmQ"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_CV8wAGhHEeijRtS4FXxxtA" name="CUTE_Settings">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_CV8wAWhHEeijRtS4FXxxtA" name="CUTE_Settings">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_CV8wAmhHEeijRtS4FXxxtA" client="_CV8wAWhHEeijRtS4FXxxtA" supplier="_CV8wBGhHEeijRtS4FXxxtA" contract="_CV8wBGhHEeijRtS4FXxxtA"/>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_CV8wA2hHEeijRtS4FXxxtA" client="_CV8wAWhHEeijRtS4FXxxtA" supplier="_CV8wDGhHEeijRtS4FXxxtA" contract="_CV8wDGhHEeijRtS4FXxxtA"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_CV8wBGhHEeijRtS4FXxxtA" name="CUTE_Settings">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_JgeAgGhIEeijRtS4FXxxtA" name="start">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_LskrsGhIEeijRtS4FXxxtA" name="strategy">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
            </ownedParameter>
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_LsxgAGhIEeijRtS4FXxxtA" name="execTime">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_VLeEMN7aEeiBkYD2qJeUwg" name="totalIterations">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_LsrZYGhIEeijRtS4FXxxtA" name="transitionIterations">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_CV8wCGhHEeijRtS4FXxxtA" name="CUTE_Settings~"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_CV8wCmhHEeijRtS4FXxxtA" client="_CV8wAWhHEeijRtS4FXxxtA" supplier="_CV8wCGhHEeijRtS4FXxxtA"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_CV8wC2hHEeijRtS4FXxxtA" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_CV8wDGhHEeijRtS4FXxxtA" name="CUTE_SettingsIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_CV8wDWhHEeijRtS4FXxxtA" client="_CV8wAWhHEeijRtS4FXxxtA" supplier="_CV8wDGhHEeijRtS4FXxxtA"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_JglVQGhIEeijRtS4FXxxtA" operation="_JgeAgGhIEeijRtS4FXxxtA"/>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_k8svIGgnEeijRtS4FXxxtA" name="Testing_DRC_Capsule">
      <packagedElement xmi:type="uml:Class" xmi:id="_C62aYGgnEeijRtS4FXxxtA" name="MCUTE____DRC" classifierBehavior="_1XUoUGhEEeijRtS4FXxxtA" isActive="true">
        <ownedAttribute xmi:type="uml:Property" xmi:id="_wtzlsGgnEeijRtS4FXxxtA" name="harness" visibility="protected" type="_ZSoUsGgnEeijRtS4FXxxtA" isOrdered="true" aggregation="composite"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_tCMV8GgvEeijRtS4FXxxtA" name="testsimple" visibility="protected" type="_hpaO8GdiEeiqifykceCvxw" isOrdered="true" aggregation="composite"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_jct8kGhHEeijRtS4FXxxtA" name="settings" visibility="protected" type="_CV8wAWhHEeijRtS4FXxxtA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true" isService="false"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_JjTisGm0EeiLpMcT--nfLg" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_4Yk0cORnEeiwK5UPZ22vmQ" name="timingInit" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_18iawGgvEeijRtS4FXxxtA" name="RTConnector1">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_18kP8GgvEeijRtS4FXxxtA" partWithPort="_wtzlsGgnEeijRtS4FXxxtA" role="_z-v4YGgvEeijRtS4FXxxtA"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_18kP8WgvEeijRtS4FXxxtA" partWithPort="_tCMV8GgvEeijRtS4FXxxtA" role="_GQwmUGdjEeiqifykceCvxw"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_3ASWwGgvEeijRtS4FXxxtA" name="RTConnector2">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_3AUL8GgvEeijRtS4FXxxtA" partWithPort="_wtzlsGgnEeijRtS4FXxxtA" role="_rximYGgvEeijRtS4FXxxtA"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_3AUL8WgvEeijRtS4FXxxtA" partWithPort="_tCMV8GgvEeijRtS4FXxxtA" role="_ugLW4GgvEeijRtS4FXxxtA"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_nU5IAGhHEeijRtS4FXxxtA" name="RTConnector3">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_nU69MGhHEeijRtS4FXxxtA" role="_jct8kGhHEeijRtS4FXxxtA"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_nU7kQGhHEeijRtS4FXxxtA" partWithPort="_wtzlsGgnEeijRtS4FXxxtA" role="_gsG2IGhHEeijRtS4FXxxtA"/>
        </ownedConnector>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_1XUoUGhEEeijRtS4FXxxtA" name="StateMachineTOP_Test" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_1XoKUGhEEeijRtS4FXxxtA" name="Region">
            <transition xmi:type="uml:Transition" xmi:id="_1Xx7UGhEEeijRtS4FXxxtA" name="Initial" source="_1XtC0GhEEeijRtS4FXxxtA" target="_y1C6cORnEeiwK5UPZ22vmQ"/>
            <transition xmi:type="uml:Transition" xmi:id="_0z7B8ORnEeiwK5UPZ22vmQ" name="" source="_y1C6cORnEeiwK5UPZ22vmQ" target="_1XwGIGhEEeijRtS4FXxxtA">
              <trigger xmi:type="uml:Trigger" xmi:id="__Bd0AORnEeiwK5UPZ22vmQ" port="_4Yk0cORnEeiwK5UPZ22vmQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_1XtC0GhEEeijRtS4FXxxtA"/>
            <subvertex xmi:type="uml:State" xmi:id="_1XwGIGhEEeijRtS4FXxxtA" name="Starting">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_7bLoMGhEEeijRtS4FXxxtA" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>char* strategy = &quot;DFS&quot;; //default strategy
int transitionIterations = 5; //default
int time = 0; //default time
int totalIterations = 0;
//read terminal inputs
int argc = UMLRTMain::getArgCount();
log.log(&quot;params count: %d&quot;, argc);
if (argc==1) {
	const char * arg = UMLRTMain::getArg(0);
	if (!strcmp(arg, &quot;-h&quot;)) {
		log.log(&quot; -ac : options for running the action code on transitions: comp, df &quot;);
		log.log(&quot; -nt : options for selecting the next transition, either random, max branches, or transition depenencies: rand, branch, dep &quot;);
		log.log(&quot; example run : ./ConcolicMain -nt random  -this command runs the concolic testing and when multiple outgoing transitions are available, randomly picks one &quot;);
	} 
}
else if (argc==4) {
	//const char * arg = UMLRTMain::getArg(0);
	//const char * arg1 = UMLRTMain::getArg(1);
	//const char * arg2 = UMLRTMain::getArg(2);
	//log.log(&quot;  0:%s, 1:%s, 2:%s  &quot; , arg, arg1, arg2);


	strategy = (char*) UMLRTMain::getArg(0);

	const char * timeStr = UMLRTMain::getArg(1);
	time = atoi(timeStr);

	const char * totalIterationsStr = UMLRTMain::getArg(2);
	totalIterations = atoi(totalIterationsStr);

	const char * transitionIterationsStr = UMLRTMain::getArg(3);
	if (atoi(transitionIterationsStr)>0) {
		transitionIterations = atoi(transitionIterationsStr);
	}

	settings.start(strategy, time, totalIterations, transitionIterations).send(); //default 5 seconds
}else{
	log.log(&quot; -ac : options for running the action code on transitions: comp, df &quot;);
	log.log(&quot; -nt : options for selecting the next transition, either random, max branches, or transition depenencies: rand, branch, dep &quot;);
	log.log(&quot; example run : ./ConcolicMain -nt random  -this command runs the concolic testing and when multiple outgoing transitions are available, randomly picks one &quot;);
}
</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_y1C6cORnEeiwK5UPZ22vmQ" name="Init">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_-XMvAORnEeiwK5UPZ22vmQ" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>timingInit.informIn(UMLRTTimespec(0.5,0));</body>
              </entry>
            </subvertex>
          </region>
        </ownedBehavior>
        <nestedClassifier xmi:type="uml:Class" xmi:id="_1gRhQGhKEeijRtS4FXxxtA" name="CUTE__MAIN__" classifierBehavior="_1gRhRmhKEeijRtS4FXxxtA" isActive="true">
          <ownedAttribute xmi:type="uml:Property" xmi:id="_1gRhQWhKEeijRtS4FXxxtA" name="harness" visibility="protected" type="_ZSoUsGgnEeijRtS4FXxxtA" isOrdered="true" aggregation="composite"/>
          <ownedAttribute xmi:type="uml:Port" xmi:id="_1gRhQmhKEeijRtS4FXxxtA" name="settings" visibility="protected" type="_CV8wAWhHEeijRtS4FXxxtA" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true" isService="false"/>
          <ownedConnector xmi:type="uml:Connector" xmi:id="_1gRhQ2hKEeijRtS4FXxxtA" name="RTConnector3">
            <end xmi:type="uml:ConnectorEnd" xmi:id="_1gRhRGhKEeijRtS4FXxxtA" role="_1gRhQmhKEeijRtS4FXxxtA"/>
            <end xmi:type="uml:ConnectorEnd" xmi:id="_1gRhRWhKEeijRtS4FXxxtA" partWithPort="_1gRhQWhKEeijRtS4FXxxtA" role="_gsG2IGhHEeijRtS4FXxxtA"/>
          </ownedConnector>
          <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_1gRhRmhKEeijRtS4FXxxtA" name="StateMachineTOP_Test" isReentrant="false">
            <region xmi:type="uml:Region" xmi:id="_1gRhR2hKEeijRtS4FXxxtA" name="Region">
              <transition xmi:type="uml:Transition" xmi:id="_1gRhSGhKEeijRtS4FXxxtA" name="Initial" source="_1gRhSWhKEeijRtS4FXxxtA" target="_1gRhSmhKEeijRtS4FXxxtA"/>
              <subvertex xmi:type="uml:Pseudostate" xmi:id="_1gRhSWhKEeijRtS4FXxxtA"/>
              <subvertex xmi:type="uml:State" xmi:id="_1gRhSmhKEeijRtS4FXxxtA" name="State1">
                <entry xmi:type="uml:OpaqueBehavior" xmi:id="_1gRhS2hKEeijRtS4FXxxtA" name="Entry" isReentrant="false">
                  <language>C++</language>
                  <body>//read terminal inputs</body>
                </entry>
              </subvertex>
            </region>
          </ownedBehavior>
        </nestedClassifier>
      </packagedElement>
    </packagedElement>
    <packagedElement xmi:type="uml:Enumeration" xmi:id="_TEwR0H5PEeipA49rzMw2KQ" name="STATES">
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_TEwR0X5PEeipA49rzMw2KQ" name="SETUP"/>
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_TEwR0n5PEeipA49rzMw2KQ" name="FILLING"/>
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_TEwR035PEeipA49rzMw2KQ" name="ABORTED"/>
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_TEwR1H5PEeipA49rzMw2KQ" name="DYEING"/>
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_TEwR1X5PEeipA49rzMw2KQ" name="DRAINING"/>
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_HhfGEH8XEeipA49rzMw2KQ" name="DONE"/>
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_pA-mIN7GEeiBkYD2qJeUwg" name="INIT"/>
    </packagedElement>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_fuzjc2diEeiqifykceCvxw">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_fuzjdGdiEeiqifykceCvxw" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_fuzjdWdiEeiqifykceCvxw">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_fuzjdmdiEeiqifykceCvxw" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_fuzjd2diEeiqifykceCvxw">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_fuzjeGdiEeiqifykceCvxw" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
    </profileApplication>
  </uml:Model>
  <UMLRealTime:Capsule xmi:id="_hphjsGdiEeiqifykceCvxw" base_Class="_hpaO8GdiEeiqifykceCvxw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_jRHzoGdiEeiqifykceCvxw" base_Pseudostate="_jREJQGdiEeiqifykceCvxw"/>
  <UMLRTStateMachines:RTState xmi:id="_jRNTMGdiEeiqifykceCvxw" base_State="_jRLeAGdiEeiqifykceCvxw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_jRQWgGdiEeiqifykceCvxw" base_Region="_jRBF8GdiEeiqifykceCvxw"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_jRXEMGdiEeiqifykceCvxw" base_StateMachine="_jPbKgGdiEeiqifykceCvxw"/>
  <UMLRealTime:ProtocolContainer xmi:id="_oIWoUGdiEeiqifykceCvxw" base_Package="_oIUzIGdiEeiqifykceCvxw"/>
  <UMLRealTime:RTMessageSet xmi:id="_oIZroGdiEeiqifykceCvxw" base_Interface="_oIYdgGdiEeiqifykceCvxw"/>
  <UMLRealTime:RTMessageSet xmi:id="_oId9EGdiEeiqifykceCvxw" base_Interface="_oIcu8GdiEeiqifykceCvxw" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_oIhAYGdiEeiqifykceCvxw" base_Interface="_oIfyQGdiEeiqifykceCvxw" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_oIi1kGdiEeiqifykceCvxw" base_Collaboration="_oIRIwGdiEeiqifykceCvxw"/>
  <UMLRTStateMachines:RTState xmi:id="_xgVEUGdiEeiqifykceCvxw" base_State="_xgSBAGdiEeiqifykceCvxw"/>
  <UMLRealTime:RTPort xmi:id="_GQzCkGdjEeiqifykceCvxw" base_Port="_GQwmUGdjEeiqifykceCvxw"/>
  <UMLRealTime:RTPort xmi:id="_M47XsGdkEeiqifykceCvxw" isWired="false" base_Port="_M4ddoGdkEeiqifykceCvxw"/>
  <UMLRealTime:Capsule xmi:id="_C70DsGgnEeijRtS4FXxxtA" base_Class="_C62aYGgnEeijRtS4FXxxtA"/>
  <UMLRealTime:Capsule xmi:id="_ZS3lRmgnEeijRtS4FXxxtA" base_Class="_ZSoUsGgnEeijRtS4FXxxtA"/>
  <UMLRealTime:CapsulePart xmi:id="_wt2pAGgnEeijRtS4FXxxtA" base_Property="_wtzlsGgnEeijRtS4FXxxtA"/>
  <UMLRealTime:ProtocolContainer xmi:id="_FiwXIGgvEeijRtS4FXxxtA" base_Package="_FivJAGgvEeijRtS4FXxxtA"/>
  <UMLRealTime:RTMessageSet xmi:id="_Fi0BgGgvEeijRtS4FXxxtA" base_Interface="_FiyMUGgvEeijRtS4FXxxtA"/>
  <UMLRealTime:RTMessageSet xmi:id="_Fi46AGgvEeijRtS4FXxxtA" base_Interface="_Fi3r4GgvEeijRtS4FXxxtA" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_Fi8kYGgvEeijRtS4FXxxtA" base_Interface="_Fi6vMGgvEeijRtS4FXxxtA" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_Fi-ZkGgvEeijRtS4FXxxtA" base_Collaboration="_FiiUsGgvEeijRtS4FXxxtA"/>
  <UMLRealTime:RTPort xmi:id="_rxp7IGgvEeijRtS4FXxxtA" base_Port="_rximYGgvEeijRtS4FXxxtA"/>
  <UMLRealTime:CapsulePart xmi:id="_tCOyMGgvEeijRtS4FXxxtA" base_Property="_tCMV8GgvEeijRtS4FXxxtA"/>
  <UMLRealTime:RTPort xmi:id="_ugNzIGgvEeijRtS4FXxxtA" base_Port="_ugLW4GgvEeijRtS4FXxxtA"/>
  <UMLRealTime:RTPort xmi:id="_z-yUoGgvEeijRtS4FXxxtA" base_Port="_z-v4YGgvEeijRtS4FXxxtA"/>
  <UMLRealTime:RTConnector xmi:id="_18k3AGgvEeijRtS4FXxxtA" base_Connector="_18iawGgvEeijRtS4FXxxtA"/>
  <UMLRealTime:RTConnector xmi:id="_3AUL8mgvEeijRtS4FXxxtA" base_Connector="_3ASWwGgvEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_FrK20GgwEeijRtS4FXxxtA" base_Pseudostate="_FrJBoGgwEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTState xmi:id="_FrNTEGgwEeijRtS4FXxxtA" base_State="_FrLd4GgwEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_FrN6IGgwEeijRtS4FXxxtA" base_Region="_FrHMcGgwEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_FrRkgGgwEeijRtS4FXxxtA" base_StateMachine="_FrDiEGgwEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_Gj9DgGgxEeijRtS4FXxxtA" base_Region="_GjyEYGgxEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTState xmi:id="_UtqJIGgxEeijRtS4FXxxtA" base_State="_UtmewGgxEeijRtS4FXxxtA"/>
  <UMLRealTime:RTPort xmi:id="_iqJSIGgxEeijRtS4FXxxtA" isWired="false" base_Port="_iqHc8GgxEeijRtS4FXxxtA"/>
  <UMLRealTime:RTPort xmi:id="_wUtksGgxEeijRtS4FXxxtA" isWired="false" base_Port="_wUrIcGgxEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_1Xu4AGhEEeijRtS4FXxxtA" base_Pseudostate="_1XtC0GhEEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTState xmi:id="_1XxUQGhEEeijRtS4FXxxtA" base_State="_1XwGIGhEEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_1XyiYGhEEeijRtS4FXxxtA" base_Region="_1XoKUGhEEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_1X1lsGhEEeijRtS4FXxxtA" base_StateMachine="_1XUoUGhEEeijRtS4FXxxtA"/>
  <UMLRealTime:ProtocolContainer xmi:id="_CV9XEGhHEeijRtS4FXxxtA" base_Package="_CV8wAGhHEeijRtS4FXxxtA"/>
  <UMLRealTime:Protocol xmi:id="_CV9-IGhHEeijRtS4FXxxtA" base_Collaboration="_CV8wAWhHEeijRtS4FXxxtA"/>
  <UMLRealTime:RTMessageSet xmi:id="_CV-lMGhHEeijRtS4FXxxtA" base_Interface="_CV8wBGhHEeijRtS4FXxxtA"/>
  <UMLRealTime:RTMessageSet xmi:id="_CV-lMWhHEeijRtS4FXxxtA" base_Interface="_CV8wCGhHEeijRtS4FXxxtA" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_CV_MQGhHEeijRtS4FXxxtA" base_Interface="_CV8wDGhHEeijRtS4FXxxtA" rtMsgKind="inOut"/>
  <UMLRealTime:RTPort xmi:id="_gsKggGhHEeijRtS4FXxxtA" base_Port="_gsG2IGhHEeijRtS4FXxxtA"/>
  <UMLRealTime:RTPort xmi:id="_jcvxwGhHEeijRtS4FXxxtA" base_Port="_jct8kGhHEeijRtS4FXxxtA"/>
  <UMLRealTime:RTConnector xmi:id="_nU7kQWhHEeijRtS4FXxxtA" base_Connector="_nU5IAGhHEeijRtS4FXxxtA"/>
  <UMLRealTime:Capsule xmi:id="_1gUkkGhKEeijRtS4FXxxtA" base_Class="_1gRhQGhKEeijRtS4FXxxtA"/>
  <UMLRealTime:CapsulePart xmi:id="_1gVLoGhKEeijRtS4FXxxtA" base_Property="_1gRhQWhKEeijRtS4FXxxtA"/>
  <UMLRealTime:RTPort xmi:id="_1gVysGhKEeijRtS4FXxxtA" base_Port="_1gRhQmhKEeijRtS4FXxxtA"/>
  <UMLRealTime:RTConnector xmi:id="_1gVysWhKEeijRtS4FXxxtA" base_Connector="_1gRhQ2hKEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_1gWZwGhKEeijRtS4FXxxtA" base_StateMachine="_1gRhRmhKEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_1gWZwWhKEeijRtS4FXxxtA" base_Region="_1gRhR2hKEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_1gXA0GhKEeijRtS4FXxxtA" base_Pseudostate="_1gRhSWhKEeijRtS4FXxxtA"/>
  <UMLRTStateMachines:RTState xmi:id="_1gXA0WhKEeijRtS4FXxxtA" base_State="_1gRhSmhKEeijRtS4FXxxtA"/>
  <UMLRealTime:RTPort xmi:id="_JjnrwGm0EeiLpMcT--nfLg" isWired="false" base_Port="_JjTisGm0EeiLpMcT--nfLg"/>
  <RTCppProperties:CapsuleProperties xmi:id="_QTsRYGm0EeiLpMcT--nfLg" headerPreface="#include &quot;umlrtmain.hh&quot;" base_Class="_C62aYGgnEeijRtS4FXxxtA"/>
  <RTCppProperties:CapsuleProperties xmi:id="_YL6b8G7EEeiLpMcT--nfLg" headerPreface="#include &lt;assert.h>&#xA;#include &lt;stdio.h>&#xA;//#include &lt;sys/time.h>&#xA;#include &lt;iostream>&#xA;#include &lt;fstream>&#xA;#include &lt;string>&#xA;#include &lt;vector>&#xA;#include &lt;map>&#xA;#include &lt;algorithm>&#xA;&#xA;&#xA;#include &lt;limits>&#xA;#include &lt;cstdlib>&#xA;&#xA;#include &lt;ctime>&#xA;&#xA;#include &lt;concolic_search.h>&#xA;#include &lt;fileutil.h>&#xA;#include &lt;coverage_util.h>&#xA;#include &quot;base/basic_types.h&quot;&#xA;#include &quot;base/symbolic_execution.h&quot;&#xA;#include &quot;base/symbolic_expression.h&quot;&#xA;#include &quot;base/symbolic_interpreter.h&quot;&#xA;#include &quot;base/symbolic_path.h&quot;&#xA;#include &quot;base/symbolic_predicate.h&quot;&#xA;#include &quot;base/yices_solver.h&quot;&#xA;&#xA;&#xA;#include &quot;STATES.hh&quot;&#xA;&#xA;using namespace mcute;" headerEnding="" implementationPreface="using namespace std;&#xA;using namespace mcute;" base_Class="_ZSoUsGgnEeijRtS4FXxxtA"/>
  <RTCppProperties:CapsuleProperties xmi:id="_6u_EAH5SEeipA49rzMw2KQ" headerPreface="#include &quot;STATES.hh&quot;&#xA;&#xA;#include &lt;map>&#xA;#include &lt;assert.h>&#xA;#include &lt;vector>&#xA;#include &lt;iostream>&#xA;#include &lt;fstream>&#xA;#include &lt;string>&#xA;&#xA;#include &quot;libcrest/crest.h&quot;" base_Class="_hpaO8GdiEeiqifykceCvxw"/>
  <RTCppProperties:AttributeProperties xmi:id="_bHwlUH5XEeipA49rzMw2KQ" type="string" base_Property="_dxTFUH5VEeipA49rzMw2KQ"/>
  <UMLRTStateMachines:RTState xmi:id="_2YpuEH_gEeiMFcUmhpquNg" base_State="_2YhyQH_gEeiMFcUmhpquNg"/>
  <RTCppProperties:AttributeProperties xmi:id="_JDiJwH_qEeiMFcUmhpquNg" type="vector&lt;int>" base_Property="_ErnuUH_qEeiMFcUmhpquNg"/>
  <RTCppProperties:AttributeProperties xmi:id="_ruklcH_qEeiMFcUmhpquNg" type="vector&lt;string>" base_Property="_rujXUH_qEeiMFcUmhpquNg"/>
  <RTCppProperties:AttributeProperties xmi:id="_r5TOwH_qEeiMFcUmhpquNg" type="vector&lt;int>" base_Property="_r5SAoH_qEeiMFcUmhpquNg"/>
  <RTCppProperties:AttributeProperties xmi:id="_rs314ICmEeib_vS042iOdQ" type="map&lt;int,int>" base_Property="_rs2nwICmEeib_vS042iOdQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_H550gIVWEeiKGobklzfqdw" type="mcute::Search*" base_Property="_DtF10IVWEeiKGobklzfqdw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_cFwysKPHEeii3rHGIK9rRQ" base_Pseudostate="_cBWz0KPHEeii3rHGIK9rRQ"/>
  <UMLRTStateMachines:RTState xmi:id="_blLvYN7GEeiBkYD2qJeUwg" base_State="_bigO0N7GEeiBkYD2qJeUwg"/>
  <UMLRTStateMachines:RTState xmi:id="_joeiUOE1EeiBkYD2qJeUwg" base_State="_jodUMOE1EeiBkYD2qJeUwg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_KNHs0OE2EeiBkYD2qJeUwg" base_Pseudostate="_KNFQkOE2EeiBkYD2qJeUwg"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_TIjE0OE4EeiBkYD2qJeUwg" base_Pseudostate="_TIhPoOE4EeiBkYD2qJeUwg"/>
  <UMLRTStateMachines:RTState xmi:id="_vFLqkOIDEeitsrWbfpHoZQ" base_State="_vFIAMOIDEeitsrWbfpHoZQ"/>
  <UMLRealTime:RTPort xmi:id="_Sk7j4OIIEeitsrWbfpHoZQ" isWired="false" base_Port="_SkthcOIIEeitsrWbfpHoZQ"/>
  <RTCppProperties:ParameterProperties xmi:id="_xEHUEOIREeitsrWbfpHoZQ" type="const SymbolicExecution&amp;" base_Parameter="_g5xMYOIREeitsrWbfpHoZQ"/>
  <RTCppProperties:ParameterProperties xmi:id="_zBuQQOIREeitsrWbfpHoZQ" type="size_t" base_Parameter="_hydu8OIREeitsrWbfpHoZQ"/>
  <RTCppProperties:ParameterProperties xmi:id="_z8blAOIREeitsrWbfpHoZQ" type="vector&lt;value_t>&amp;" base_Parameter="_h2-bgOIREeitsrWbfpHoZQ"/>
  <UMLRTStateMachines:RTState xmi:id="_nNnb4OLIEeiS-ZARNzPJ8Q" base_State="_nNdD0OLIEeiS-ZARNzPJ8Q"/>
  <UMLRealTime:RTPort xmi:id="_hettcOLKEeiS-ZARNzPJ8Q" isWired="false" base_Port="_hekjgOLKEeiS-ZARNzPJ8Q"/>
  <RTCppProperties:ParameterProperties xmi:id="_sNI50OLcEeiS-ZARNzPJ8Q" type="SymbolicExecution&amp;" base_Parameter="_mCNBkOLcEeiS-ZARNzPJ8Q"/>
  <RTCppProperties:ParameterProperties xmi:id="_uG2NcOLcEeiS-ZARNzPJ8Q" type="size_t" base_Parameter="_lTceIOLcEeiS-ZARNzPJ8Q"/>
  <UMLRTStateMachines:RTState xmi:id="_P8bMEONyEeiS-ZARNzPJ8Q" base_State="_P8Yv0ONyEeiS-ZARNzPJ8Q"/>
  <UMLRTStateMachines:RTState xmi:id="_tQidMOOwEeiS-ZARNzPJ8Q" base_State="_tQgA8OOwEeiS-ZARNzPJ8Q"/>
  <UMLRealTime:RTPort xmi:id="_8clJkOOwEeiS-ZARNzPJ8Q" isWired="false" base_Port="_8ciGQOOwEeiS-ZARNzPJ8Q"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_KISwkOQ-EeitooxfkYAKHg" base_Pseudostate="_KIQUUOQ-EeitooxfkYAKHg"/>
  <UMLRTStateMachines:RTState xmi:id="_-9-cIORcEeiwK5UPZ22vmQ" base_State="_-97_4ORcEeiwK5UPZ22vmQ"/>
  <UMLRTStateMachines:RTState xmi:id="_ayW9gORnEeiwK5UPZ22vmQ" base_State="_ayVIUORnEeiwK5UPZ22vmQ"/>
  <UMLRTStateMachines:RTState xmi:id="_y1EvoORnEeiwK5UPZ22vmQ" base_State="_y1C6cORnEeiwK5UPZ22vmQ"/>
  <UMLRealTime:RTPort xmi:id="_4Yps8ORnEeiwK5UPZ22vmQ" isWired="false" base_Port="_4Yk0cORnEeiwK5UPZ22vmQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_PsAQwOavEeiwK5UPZ22vmQ" type="vector&lt;coverage_util>" base_Property="_KvXXoOavEeiwK5UPZ22vmQ"/>
  <UMLRTStateMachines:RTState xmi:id="_5vBGAOhkEeidvedyZ74wtA" base_State="_5u_Q0OhkEeidvedyZ74wtA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_Sy_g0OhlEeidvedyZ74wtA" base_Pseudostate="_Sy9EkOhlEeidvedyZ74wtA"/>
  <RTCppProperties:AttributeProperties xmi:id="_55O8gOhlEeidvedyZ74wtA" type="string" base_Property="_55OVcOhlEeidvedyZ74wtA"/>
  <UMLRTStateMachines:RTRegion xmi:id="_IBlXQOhmEeidvedyZ74wtA" base_Region="_IBdbcOhmEeidvedyZ74wtA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_ICTI8OhmEeidvedyZ74wtA" base_Pseudostate="_ICRTwOhmEeidvedyZ74wtA"/>
  <UMLRTStateMachines:RTState xmi:id="_JCxHcOhmEeidvedyZ74wtA" base_State="_JCv5UOhmEeidvedyZ74wtA"/>
  <UMLRTStateMachines:RTState xmi:id="_JYrGAOhmEeidvedyZ74wtA" base_State="_JYpQ0OhmEeidvedyZ74wtA"/>
  <UMLRealTime:RTPort xmi:id="_eBxLUOjyEeidvedyZ74wtA" isWired="false" base_Port="_eBp2kOjyEeidvedyZ74wtA"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_ev-i4Oj3EeiYDrXBQFB6pw" base_Pseudostate="_evvSUOj3EeiYDrXBQFB6pw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_hxKb8Oj3EeiYDrXBQFB6pw" base_Pseudostate="_hxFjcOj3EeiYDrXBQFB6pw"/>
  <UMLRealTime:RTPort xmi:id="_GQzKgOk0EeiYVL3mrKgfUA" isWired="false" base_Port="_GQg2oOk0EeiYVL3mrKgfUA"/>
  <RTCppProperties:AttributeProperties xmi:id="_-LUtUO93EeiBrOAOs4BT-g" type="map&lt;string,coverage_util*>" base_Property="_-LTfMO93EeiBrOAOs4BT-g"/>
  <UMLRTStateMachines:RTState xmi:id="_U0ggsO94EeiBrOAOs4BT-g" base_State="_U0eEcO94EeiBrOAOs4BT-g"/>
  <UMLRTStateMachines:RTRegion xmi:id="_agkEkO94EeiBrOAOs4BT-g" base_Region="_aggaMO94EeiBrOAOs4BT-g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_agt1kO94EeiBrOAOs4BT-g" base_Pseudostate="_agpkIO94EeiBrOAOs4BT-g"/>
  <UMLRTStateMachines:RTState xmi:id="_bXuWEO94EeiBrOAOs4BT-g" base_State="_bXr50O94EeiBrOAOs4BT-g"/>
  <UMLRealTime:RTPort xmi:id="_nzy7EPC-EeiBrOAOs4BT-g" isWired="false" base_Port="_nxRLgPC-EeiBrOAOs4BT-g"/>
  <UMLRTStateMachines:RTState xmi:id="_sO8QsPC-EeiBrOAOs4BT-g" base_State="_sO50cPC-EeiBrOAOs4BT-g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_ATT98PC_EeiBrOAOs4BT-g" base_Pseudostate="_ATKM8PC_EeiBrOAOs4BT-g"/>
  <UMLRTStateMachines:RTState xmi:id="_z5CZIfC_EeiBrOAOs4BT-g" base_State="_z4x6cPC_EeiBrOAOs4BT-g"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_-5t2gPD6EeiEK7ZB4QGZMA" base_Pseudostate="_-5mhwPD6EeiEK7ZB4QGZMA"/>
  <UMLRTStateMachines:RTState xmi:id="_HppMUPEBEeiEK7ZB4QGZMA" base_State="_HpmwEPEBEeiEK7ZB4QGZMA"/>
</xmi:XMI>
