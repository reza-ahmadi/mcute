1- crectc: 
   - calls cil to generate .i and .c files
   - builds an executable binary from the instrumented file
2. the instumented file calls in its different locations functions inside the crest.cc class. crest.cc includes functions to write the symbolic execution object into a file "szd_execution"

3- runcrest runs an algorithm. 

4. the above file (szd_execution), is generated in every iteration that the instrumented file is executed.

5. the above file (szd_execution) is deserialized into an object and used everytime that an algorithm (e.g. DFS) is called.

6. we can save szd_execution files (in a vector) for every transition, and append them to the head of the constrains that are generate for the next transitions.

7. LaunchProgram function in the concolic_search class in fact sends the inputs via ports to the CUT to run it, as well. (in addition to execute the action code of the transitions saved into seperate files). This part should be done in the test harness, since other classes can hardly send messages to the ports (to be received by the CUT).

8. much of the code written in the concolic_search class remains in the same file, only parts that need to communicate with the CUT are moved to the TH.



