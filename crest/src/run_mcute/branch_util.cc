// Copyright (c) 2018, Reza Ahmadi (ahmadi@cs.queensu.ca)
//
// This file is part of mCUTE, which is distributed under the revised
// BSD license.  A copy of this license can be found in the file LICENSE.
//
// This program is distributed in the hope that it will be useful, but
// WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See LICENSE
// for details.

#include <algorithm>
#include <assert.h>
#include <cmath>
#include <fstream>
#include <functional>
#include <limits>
#include <stdio.h>
#include <stdlib.h>
#include <queue>
#include <utility>

#include "run_mcute/branch_util.h"


// #include "base/yices_solver.h"
// #include "base/basic_types.h"
// //#include "run_mcute/concolic_search.h"
// #include "base/symbolic_execution.h"
// #include <iostream>

using std::binary_function;
using std::ifstream;
using std::ios;
using std::cout;
using std::cin;
using std::endl;
using std::min;
using std::max;
using std::numeric_limits;
using std::pair;
using std::queue;
using std::random_shuffle;
using std::stable_sort;

namespace mcute {


  ////////////////////////////////////////////////////////////////////////
  //// negate ////////////////////////////////////////////////////////////
  ////////////////////////////////////////////////////////////////////////

  void branch_util::negate(const SymbolicExecution& ex, int& depth){

    int constraints = ex.path().constraints().size();

    printf ("Harness: Depth is: %d, Constraints are:%d\n", depth, constraints);
    //print SE object info
    fileutil::printSymExObj(false, true, false);

    if (depth<constraints){
      printf ("Harness: Negating_Solving_Gen, Depth is: %d, Constraints are:%d", depth, constraints);
      //handle iteration
      //0. read the symbolic execution object
      // Read the symbolic execution object of the previous execution of the transition
      // SymbolicExecution ex;
      // std::ifstream in("szd_execution", std::ios::in | std::ios::binary);
      // ex.Parse(in);
      // in.close();

      //1. negate and solve the PCs
      //ToDo: how to actually call SolveAtBranch
      vector<value_t> input;
      printf("number of constraints are: %d", ex.path().constraints().size());
      //for (size_t i = 0; (i < ex.path().constraints().size()); i++) {
      //	if (i%2==1)
      printf("\n---Call SolveAtBranch, depth: %d", depth);
      solveAtBranch(ex, depth, input);
      //}
      depth++;
      //print the generated inputs
      std::cout << "\n-----printing inputs generated by the Concolic engine-------\n";
      for (size_t i = 0; i < input.size(); i++) {
        std::cout << ":" << input[i] << std::endl;
      }
      //write the inputs to a file, since SI object is initialized by these inputs
      fileutil::writeInputs("input", input);
    }else{
      depth=0;
    }
  }

  bool branch_util::solveAtBranch(const SymbolicExecution& ex, int branch_idx, vector<value_t>& input){
    const vector<SymbolicPred*>& constraints = ex.path().constraints();

    // Optimization: If any of the previous constraints are idential to the
    // branch_idx-th constraint, immediately return false.
    for (int i = static_cast<int>(branch_idx) - 1; i >= 0; i--) {
      if (constraints[branch_idx]->Equal(*constraints[i]))
      return false;
    }

    vector<const SymbolicPred*> cs(constraints.begin(),
    constraints.begin() + branch_idx + 1);
    map<var_t, value_t> soln;
    constraints[branch_idx]->Negate();
    // fprintf(stderr, "Yices . . . ");
    bool success = YicesSolver::IncrementalSolve(ex.inputs(), ex.vars(), cs,
    &soln);
    // fprintf(stderr, "%d\n", success);
    constraints[branch_idx]->Negate();

    if (success) {
      // Merge the solution with the previous input to get the next
      // input.  (Could merge with random inputs, instead.)
      input = ex.inputs();
      // RandomInput(ex.vars(), input);

      typedef map<var_t, value_t>::const_iterator SolnIt;
      for (SolnIt i = soln.begin(); i != soln.end(); ++i) {
        input[i->first] = i->second;
      }
      return true;
    }

    return false;

  }

}  // namespace mcute
