<?xml version="1.0" encoding="UTF-8"?>
<xmi:XMI xmi:version="20131001" xmlns:xmi="http://www.omg.org/spec/XMI/20131001" xmlns:RTCppProperties="http://www.eclipse.org/papyrus/umlrt/cppproperties" xmlns:UMLRTStateMachines="http://www.eclipse.org/papyrus/umlrt/statemachine" xmlns:UMLRealTime="http://www.eclipse.org/papyrus/umlrt" xmlns:ecore="http://www.eclipse.org/emf/2002/Ecore" xmlns:uml="http://www.eclipse.org/uml2/5.0.0/UML">
  <uml:Model xmi:id="_FkT7cA7lEem-ucXEfNJLZw" name="buggyModel">
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_FkT7cQ7lEem-ucXEfNJLZw" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_FkT7cg7lEem-ucXEfNJLZw" key="language" value="umlrt-cpp"/>
    </eAnnotations>
    <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_G71dIA7nEem-ucXEfNJLZw" source="UMLRT_Default_top">
      <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_G72EMA7nEem-ucXEfNJLZw" key="top_name" value="mCUTE__TOP"/>
    </eAnnotations>
    <packagedElement xmi:type="uml:Class" xmi:id="_IYrggA7lEem-ucXEfNJLZw" name="Capsule2" classifierBehavior="_K-6i8A7lEem-ucXEfNJLZw" isActive="true">
      <ownedAttribute xmi:type="uml:Port" xmi:id="_vo8TgA7oEem-ucXEfNJLZw" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_6YxWcA7sEem-ucXEfNJLZw" name="port1" type="_jyxZ8A7sEem-ucXEfNJLZw" isOrdered="true" aggregation="composite" isBehavior="true"/>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_G5uI8CNOEem03smGE4oJWg" name="timing" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
        <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
      </ownedAttribute>
      <ownedAttribute xmi:type="uml:Port" xmi:id="_WXlHoEpqEemahN0jopeFxQ" name="commands" type="_WXg3IkpqEemahN0jopeFxQ" isBehavior="true" isConjugated="true"/>
      <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_K-6i8A7lEem-ucXEfNJLZw" name="StateMachine" isReentrant="false">
        <region xmi:type="uml:Region" xmi:id="_K_UyoA7lEem-ucXEfNJLZw" name="Region">
          <transition xmi:type="uml:Transition" xmi:id="_K_qJ0A7lEem-ucXEfNJLZw" name="Initial" source="_K_ZEEA7lEem-ucXEfNJLZw" target="_K_l4YA7lEem-ucXEfNJLZw"/>
          <transition xmi:type="uml:Transition" xmi:id="_Mc5hABwkEemGs84svc1UIQ" name="t1" kind="external" source="_K_l4YA7lEem-ucXEfNJLZw" target="_LkTsIBwkEemGs84svc1UIQ">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WEE80EpqEemahN0jopeFxQ">
              <language>C++</language>
              <body>__CrestInit();
  __CrestCall(1, 1);
#line 6
  __CrestInt(&amp; p1);
#line 7
  __CrestInt(&amp; p3);
  __CrestLoad(4, (unsigned long )(&amp; p1), (long long )p1);
  __CrestLoad(3, (unsigned long )0, (long long )0);
  __CrestApply2(2, 14, (long long )(p1 > 0));
#line 7
  if (p1 > 0) {
    __CrestBranch(5, 103, 1);
    {
    __CrestLoad(9, (unsigned long )(&amp; p1), (long long )p1);
    __CrestLoad(8, (unsigned long )0, (long long )100);
    __CrestApply2(7, 16, (long long )(p1 &lt; 100));
#line 7
    if (p1 &lt; 100) {
      __CrestBranch(10, 104, 1);
#line 8
      printf((char const   * __restrict  )&quot;\n(p1>0 &amp;&amp; p1&lt;100) || (p1*2>22000)&quot;);
      __CrestClearStack(12);
    } else {
      __CrestBranch(11, 105, 0);
#line 7
      goto _L;
    }
    }
  } else {
    __CrestBranch(6, 106, 0);
    _L: /* CIL Label */ 
    {
    __CrestLoad(17, (unsigned long )(&amp; p1), (long long )p1);
    __CrestLoad(16, (unsigned long )0, (long long )2);
    __CrestApply2(15, 2, (long long )(p1 * 2));
    __CrestLoad(14, (unsigned long )0, (long long )22000);
    __CrestApply2(13, 14, (long long )(p1 * 2 > 22000));
#line 7
    if (p1 * 2 > 22000) {
      __CrestBranch(18, 107, 1);
#line 8
      printf((char const   * __restrict  )&quot;\n(p1>0 &amp;&amp; p1&lt;100) || (p1*2>22000)&quot;);
      __CrestClearStack(20);
    } else {
      __CrestBranch(19, 108, 0);

    }
    }
  }
  __CrestReturn(21);
#line 4
__CrestClearStack(0); 
 __CrestWriteSE(); 
</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_ORwJ0BwkEemGs84svc1UIQ" event="_lz3hABu7EemGs84svc1UIQ" port="_6YxWcA7sEem-ucXEfNJLZw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_NDsbQBwkEemGs84svc1UIQ" name="t3" kind="external" source="_-dosoBwqEemGs84svc1UIQ" target="_L8BokBwkEemGs84svc1UIQ">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WKoQwEpqEemahN0jopeFxQ">
              <language>C++</language>
              <body>
  __CrestCall(1, 1);
#line 6
  __CrestInt(&amp; p1);
#line 7
  __CrestInt(&amp; p2);
  __CrestLoad(4, (unsigned long )(&amp; p2), (long long )p2);
  __CrestLoad(3, (unsigned long )0, (long long )0);
  __CrestApply2(2, 14, (long long )(p2 > 0));
#line 7
  if (p2 > 0) {
    __CrestBranch(5, 303, 1);
#line 7
    goto _L;
  } else {
    __CrestBranch(6, 304, 0);
    {
    __CrestLoad(9, (unsigned long )(&amp; p2), (long long )p2);
    __CrestLoad(8, (unsigned long )0, (long long )-1);
    __CrestApply2(7, 16, (long long )(p2 &lt; -1));
#line 7
    if (p2 &lt; -1) {
      __CrestBranch(10, 305, 1);
#line 7
      goto _L;
    } else {
      __CrestBranch(11, 306, 0);
      {
      __CrestLoad(14, (unsigned long )(&amp; p2), (long long )p2);
      __CrestLoad(13, (unsigned long )0, (long long )2000);
      __CrestApply2(12, 17, (long long )(p2 >= 2000));
#line 7
      if (p2 >= 2000) {
        __CrestBranch(15, 307, 1);
        _L: /* CIL Label */ 
#line 8
        printf((char const   * __restrict  )&quot;\n(p2>0 || p2&lt;-1 || p2>=2000)&quot;);
        __CrestClearStack(17);
        {
        __CrestLoad(22, (unsigned long )(&amp; p2), (long long )p2);
        __CrestLoad(21, (unsigned long )0, (long long )2);
        __CrestApply2(20, 2, (long long )(p2 * 2));
        __CrestLoad(19, (unsigned long )0, (long long )1000);
        __CrestApply2(18, 14, (long long )(p2 * 2 > 1000));
#line 9
        if (p2 * 2 > 1000) {
          __CrestBranch(23, 309, 1);
          {
          __CrestLoad(27, (unsigned long )(&amp; p1), (long long )p1);
          __CrestLoad(26, (unsigned long )0, (long long )0);
          __CrestApply2(25, 14, (long long )(p1 > 0));
#line 9
          if (p1 > 0) {
            __CrestBranch(28, 310, 1);
            {
            __CrestLoad(32, (unsigned long )(&amp; p1), (long long )p1);
            __CrestLoad(31, (unsigned long )(&amp; p2), (long long )p2);
            __CrestApply2(30, 12, (long long )(p1 == p2));
#line 9
            if (p1 == p2) {
              __CrestBranch(33, 311, 1);
              {
              __CrestLoad(37, (unsigned long )(&amp; p1), (long long )p1);
              __CrestLoad(36, (unsigned long )0, (long long )50000);
              __CrestApply2(35, 16, (long long )(p1 &lt; 50000));
#line 10
              if (p1 &lt; 50000) {
                __CrestBranch(38, 312, 1);
#line 11
                printf((char const   * __restrict  )&quot;\ndevision by zero here!\n&quot;);
                __CrestClearStack(40);
#line 12
                printf((char const   * __restrict  )&quot;p1=%d, p2=%d&quot;);
                __CrestClearStack(41);
#line 13
                printf((char const   * __restrict  )&quot;some basic math: p2 = 200 / (p1-p2)&quot;);
                __CrestClearStack(42);
                __CrestLoad(47, (unsigned long )0, (long long )200);
                __CrestLoad(46, (unsigned long )(&amp; p1), (long long )p1);
                __CrestLoad(45, (unsigned long )(&amp; p2), (long long )p2);
                __CrestApply2(44, 1, (long long )(p1 - p2));
                __CrestApply2(43, 3, (long long )(200 / (p1 - p2)));
                __CrestStore(48, (unsigned long )(&amp; p2));
#line 14
                p2 = 200 / (p1 - p2);
#line 15
                printf((char const   * __restrict  )&quot;basic math done!\n&quot;);
                __CrestClearStack(49);
              } else {
                __CrestBranch(39, 313, 0);

              }
              }
            } else {
              __CrestBranch(34, 314, 0);

            }
            }
          } else {
            __CrestBranch(29, 315, 0);

          }
          }
        } else {
          __CrestBranch(24, 316, 0);

        }
        }
      } else {
        __CrestBranch(16, 317, 0);

      }
      }
    }
    }
  }
  __CrestReturn(50);
#line 4
__CrestClearStack(0); 
 __CrestWriteSE(); 
</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_0Gzs8B1BEemqm5ALxX3dkg" event="_qq9LwBu7EemGs84svc1UIQ" port="_6YxWcA7sEem-ucXEfNJLZw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="__Hfh8BwqEemGs84svc1UIQ" name="t2" kind="external" source="_LkTsIBwkEemGs84svc1UIQ" target="_-dosoBwqEemGs84svc1UIQ">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WHPlkEpqEemahN0jopeFxQ">
              <language>C++</language>
              <body>
  __CrestCall(1, 1);
#line 6
  __CrestInt(&amp; p1);
#line 7
  __CrestInt(&amp; p2);
  __CrestLoad(6, (unsigned long )(&amp; p1), (long long )p1);
  __CrestLoad(5, (unsigned long )0, (long long )2);
  __CrestApply2(4, 2, (long long )(p1 * 2));
  __CrestLoad(3, (unsigned long )0, (long long )100);
  __CrestApply2(2, 14, (long long )(p1 * 2 > 100));
#line 7
  if (p1 * 2 > 100) {
    __CrestBranch(7, 203, 1);
    {
    __CrestLoad(13, (unsigned long )(&amp; p1), (long long )p1);
    __CrestLoad(12, (unsigned long )(&amp; p2), (long long )p2);
    __CrestApply2(11, 1, (long long )(p1 - p2));
    __CrestLoad(10, (unsigned long )0, (long long )2);
    __CrestApply2(9, 14, (long long )(p1 - p2 > 2));
#line 7
    if (p1 - p2 > 2) {
      __CrestBranch(14, 204, 1);
      {
      __CrestLoad(20, (unsigned long )(&amp; p2), (long long )p2);
      __CrestLoad(19, (unsigned long )0, (long long )2);
      __CrestApply2(18, 2, (long long )(p2 * 2));
      __CrestLoad(17, (unsigned long )0, (long long )1000);
      __CrestApply2(16, 16, (long long )(p2 * 2 &lt; 1000));
#line 7
      if (p2 * 2 &lt; 1000) {
        __CrestBranch(21, 205, 1);
        {
        __CrestLoad(27, (unsigned long )(&amp; p1), (long long )p1);
        __CrestLoad(26, (unsigned long )(&amp; p2), (long long )p2);
        __CrestApply2(25, 0, (long long )(p1 + p2));
        __CrestLoad(24, (unsigned long )0, (long long )40000);
        __CrestApply2(23, 16, (long long )(p1 + p2 &lt; 40000));
#line 7
        if (p1 + p2 &lt; 40000) {
          __CrestBranch(28, 206, 1);
#line 8
          printf((char const   * __restrict  )&quot;\n(( p1*2>100 ) &amp;&amp; (p1-p2>2)) &amp;&amp; (p2 * 2 &lt;1000) &amp;&amp; (p1+p2&lt;40000)&quot;);
          __CrestClearStack(30);
        } else {
          __CrestBranch(29, 207, 0);

        }
        }
      } else {
        __CrestBranch(22, 208, 0);

      }
      }
    } else {
      __CrestBranch(15, 209, 0);

    }
    }
  } else {
    __CrestBranch(8, 210, 0);

  }
  __CrestReturn(31);
#line 4
__CrestClearStack(0); 
 __CrestWriteSE(); 
</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_BvFPQBwrEemGs84svc1UIQ" event="_qq9LwBu7EemGs84svc1UIQ" port="_6YxWcA7sEem-ucXEfNJLZw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_pLdYMB6KEem03smGE4oJWg" name="t5" kind="external" source="_lDZkYCNxEemrUPrz7hly4g" target="_K_l4YA7lEem-ucXEfNJLZw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WA_zoEpqEemahN0jopeFxQ">
              <language>C++</language>
              <body>
  __CrestCall(1, 1);
#line 6
  __CrestInt(&amp; p1);
#line 7
  __CrestInt(&amp; p3);
  __CrestLoad(2, (unsigned long )(&amp; p1), (long long )p1);
  __CrestLoad(3, (unsigned long )(&amp; p3), (long long )p3);
#line 7
  printf((char const   * __restrict  )&quot;\n???setting timer with: %d, %d?????\n&quot;, p1,
         p3);
  __CrestClearStack(4);
  __CrestReturn(5);
#line 4
__CrestClearStack(0); 
 __CrestWriteSE(); 
</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_oq320B6OEem03smGE4oJWg" event="_lz3hABu7EemGs84svc1UIQ" port="_6YxWcA7sEem-ucXEfNJLZw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_nFZRUCNxEemrUPrz7hly4g" name="t4" kind="external" source="_L8BokBwkEemGs84svc1UIQ" target="_lDZkYCNxEemrUPrz7hly4g">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WN0HoEpqEemahN0jopeFxQ">
              <language>C++</language>
              <body>
  __CrestCall(1, 1);
#line 6
  __CrestInt(&amp; p1);
#line 7
  __CrestInt(&amp; p3);
  __CrestLoad(2, (unsigned long )(&amp; p1), (long long )p1);
  __CrestLoad(3, (unsigned long )(&amp; p3), (long long )p3);
#line 7
  printf((char const   * __restrict  )&quot;\n???setting timer with: %d, %d?????\n&quot;, p1,
         p3);
  __CrestClearStack(4);
  __CrestReturn(5);
#line 4
__CrestClearStack(0); 
 __CrestWriteSE(); 
</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_sTQdUCNxEemrUPrz7hly4g" event="_lz3hABu7EemGs84svc1UIQ" port="_6YxWcA7sEem-ucXEfNJLZw"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_WX1mUEpqEemahN0jopeFxQ" name="iterate0" source="_K_l4YA7lEem-ucXEfNJLZw" target="_K_l4YA7lEem-ucXEfNJLZw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WX1mUUpqEemahN0jopeFxQ">
              <language>C++</language>
              <body>__CrestWriteSE();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_WX1mUkpqEemahN0jopeFxQ" event="_WX2NYEpqEemahN0jopeFxQ" port="_WXlHoEpqEemahN0jopeFxQ"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_WX2NYUpqEemahN0jopeFxQ" name="iterate1" source="_LkTsIBwkEemGs84svc1UIQ" target="_K_l4YA7lEem-ucXEfNJLZw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WX2NYkpqEemahN0jopeFxQ">
              <language>C++</language>
              <body>__CrestWriteSE();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_WX2NY0pqEemahN0jopeFxQ" event="_WX2NZEpqEemahN0jopeFxQ" port="_WXlHoEpqEemahN0jopeFxQ"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_WX2NZUpqEemahN0jopeFxQ" name="iterate2" source="_L8BokBwkEemGs84svc1UIQ" target="_K_l4YA7lEem-ucXEfNJLZw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WX20cEpqEemahN0jopeFxQ">
              <language>C++</language>
              <body>__CrestWriteSE();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_WX20cUpqEemahN0jopeFxQ" event="_WX20ckpqEemahN0jopeFxQ" port="_WXlHoEpqEemahN0jopeFxQ"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_WX20c0pqEemahN0jopeFxQ" name="iterate3" source="_-dosoBwqEemGs84svc1UIQ" target="_K_l4YA7lEem-ucXEfNJLZw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WX20dEpqEemahN0jopeFxQ">
              <language>C++</language>
              <body>__CrestWriteSE();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_WX20dUpqEemahN0jopeFxQ" event="_WX20dkpqEemahN0jopeFxQ" port="_WXlHoEpqEemahN0jopeFxQ"/>
          </transition>
          <transition xmi:type="uml:Transition" xmi:id="_WX3bgEpqEemahN0jopeFxQ" name="iterate4" source="_lDZkYCNxEemrUPrz7hly4g" target="_K_l4YA7lEem-ucXEfNJLZw">
            <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WX3bgUpqEemahN0jopeFxQ">
              <language>C++</language>
              <body>__CrestWriteSE();</body>
            </effect>
            <trigger xmi:type="uml:Trigger" xmi:id="_WX3bgkpqEemahN0jopeFxQ" event="_WX3bg0pqEemahN0jopeFxQ" port="_WXlHoEpqEemahN0jopeFxQ"/>
          </transition>
          <subvertex xmi:type="uml:Pseudostate" xmi:id="_K_ZEEA7lEem-ucXEfNJLZw" kind="initial"/>
          <subvertex xmi:type="uml:State" xmi:id="_K_l4YA7lEem-ucXEfNJLZw" name="Idle">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_NwyiwA7nEem-ucXEfNJLZw" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>log.log(&quot;State1&quot;);commands.newState(1).send();</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_LkTsIBwkEemGs84svc1UIQ" name="Warn">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_qa2igBwkEemGs84svc1UIQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>log.log(&quot;State2&quot;);commands.newState(2).send();</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_L8BokBwkEemGs84svc1UIQ" name="Mitigate">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_rAipgBwkEemGs84svc1UIQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>log.log(&quot;State4&quot;);
commands.newState(3).send();</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_-dosoBwqEemGs84svc1UIQ" name="Avoid">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_OlMmEBwrEemGs84svc1UIQ" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>log.log(&quot;State3&quot;);commands.newState(4).send();</body>
            </entry>
          </subvertex>
          <subvertex xmi:type="uml:State" xmi:id="_lDZkYCNxEemrUPrz7hly4g" name="Wait4TimeOut">
            <entry xmi:type="uml:OpaqueBehavior" xmi:id="_VJrfcDPUEemkLr3nTm6bLA" name="Entry" isReentrant="false">
              <language>C++</language>
              <body>//timing.informIn(UMLRTTimespec(0,10000));
commands.newState(5).send();</body>
            </entry>
          </subvertex>
        </region>
      </ownedBehavior>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_jy3gkA7sEem-ucXEfNJLZw" name="Protocol1">
      <packagedElement xmi:type="uml:Collaboration" xmi:id="_jyxZ8A7sEem-ucXEfNJLZw" name="Protocol1">
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_jy_cYA7sEem-ucXEfNJLZw" client="_jyxZ8A7sEem-ucXEfNJLZw" supplier="_jy7yAA7sEem-ucXEfNJLZw" contract="_jy7yAA7sEem-ucXEfNJLZw"/>
        <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_jzKbgA7sEem-ucXEfNJLZw" client="_jyxZ8A7sEem-ucXEfNJLZw" supplier="_jzGxIA7sEem-ucXEfNJLZw" contract="_jzGxIA7sEem-ucXEfNJLZw"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_jy7yAA7sEem-ucXEfNJLZw" name="Protocol1">
        <ownedOperation xmi:type="uml:Operation" xmi:id="_lz1r0Bu7EemGs84svc1UIQ" name="msg1">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_mC3mUBu7EemGs84svc1UIQ" name="p1">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_qE54YBu7EemGs84svc1UIQ" name="p3">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_qqnNgBu7EemGs84svc1UIQ" name="msg12">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_qqnNgRu7EemGs84svc1UIQ" name="p1">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_qqnNghu7EemGs84svc1UIQ" name="p2">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_quscQBu7EemGs84svc1UIQ" name="msg133">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_quscQRu7EemGs84svc1UIQ" name="p1">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_qxppoBu7EemGs84svc1UIQ" name="msg56">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_qxppoRu7EemGs84svc1UIQ" name="p1">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
      </packagedElement>
      <packagedElement xmi:type="uml:Interface" xmi:id="_jzCfsA7sEem-ucXEfNJLZw" name="Protocol1~"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_jzFjAA7sEem-ucXEfNJLZw" client="_jyxZ8A7sEem-ucXEfNJLZw" supplier="_jzCfsA7sEem-ucXEfNJLZw"/>
      <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_jzGKEA7sEem-ucXEfNJLZw" name="*"/>
      <packagedElement xmi:type="uml:Interface" xmi:id="_jzGxIA7sEem-ucXEfNJLZw" name="Protocol1IO"/>
      <packagedElement xmi:type="uml:Usage" xmi:id="_jzMQsA7sEem-ucXEfNJLZw" client="_jyxZ8A7sEem-ucXEfNJLZw" supplier="_jzGxIA7sEem-ucXEfNJLZw"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_lz3hABu7EemGs84svc1UIQ" operation="_lz1r0Bu7EemGs84svc1UIQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_qq9LwBu7EemGs84svc1UIQ" operation="_qqnNgBu7EemGs84svc1UIQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_quwGoBu7EemGs84svc1UIQ" operation="_quscQBu7EemGs84svc1UIQ"/>
      <packagedElement xmi:type="uml:CallEvent" xmi:id="_qxt7EBu7EemGs84svc1UIQ" operation="_qxppoBu7EemGs84svc1UIQ"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Enumeration" xmi:id="_V8qGMEpqEemahN0jopeFxQ" name="STATES">
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_V8qGMUpqEemahN0jopeFxQ" name="Idle"/>
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_V8qGMkpqEemahN0jopeFxQ" name="Warn"/>
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_V8qGM0pqEemahN0jopeFxQ" name="Mitigate"/>
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_V8qGNEpqEemahN0jopeFxQ" name="Avoid"/>
      <ownedLiteral xmi:type="uml:EnumerationLiteral" xmi:id="_V8qGNUpqEemahN0jopeFxQ" name="Wait4TimeOut"/>
    </packagedElement>
    <packagedElement xmi:type="uml:Package" xmi:id="_WXg2MEpqEemahN0jopeFxQ" name="mCUTE">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_WXg2MUpqEemahN0jopeFxQ" source="http://www.eclipse.org/papyrus-rt/language/1.0.0">
        <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_WXg2MkpqEemahN0jopeFxQ" key="language" value="umlrt-cpp"/>
      </eAnnotations>
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_WXg2M0pqEemahN0jopeFxQ" source="UMLRT_Default_top">
        <details xmi:type="ecore:EStringToStringMapEntry" xmi:id="_WXg2NEpqEemahN0jopeFxQ" key="top_name" value="mCUTE__TOP"/>
      </eAnnotations>
      <packagedElement xmi:type="uml:Class" xmi:id="_WXg2NUpqEemahN0jopeFxQ" name="mCUTE__TOP" classifierBehavior="_WXg2PUpqEemahN0jopeFxQ" isActive="true">
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2NkpqEemahN0jopeFxQ" name="harness" visibility="protected" type="_WXg2R0pqEemahN0jopeFxQ" isOrdered="true" aggregation="composite"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2N0pqEemahN0jopeFxQ" name="settings" visibility="protected" type="_WXg3O0pqEemahN0jopeFxQ" isOrdered="true" aggregation="composite" isBehavior="true" isConjugated="true" isService="false"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2OEpqEemahN0jopeFxQ" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2OUpqEemahN0jopeFxQ" name="timingInit" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXoK8UpqEemahN0jopeFxQ" name="cut" type="_IYrggA7lEem-ucXEfNJLZw"/>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_WXg2OkpqEemahN0jopeFxQ" name="RTConnector3">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_WXg2O0pqEemahN0jopeFxQ" role="_WXg2N0pqEemahN0jopeFxQ"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_WXg2PEpqEemahN0jopeFxQ" partWithPort="_WXg2NkpqEemahN0jopeFxQ" role="_WXg2UUpqEemahN0jopeFxQ"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_WXoyAUpqEemahN0jopeFxQ" name="con_commands_harness_cut">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_WXoyAkpqEemahN0jopeFxQ" partWithPort="_WXg2NkpqEemahN0jopeFxQ" role="_WXg2SEpqEemahN0jopeFxQ"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_WXoyA0pqEemahN0jopeFxQ" partWithPort="_WXoK8UpqEemahN0jopeFxQ" role="_WXlHoEpqEemahN0jopeFxQ"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_WXpZEUpqEemahN0jopeFxQ" name="con_port1_harness_cut">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_WXpZEkpqEemahN0jopeFxQ" partWithPort="_WXg2NkpqEemahN0jopeFxQ" role="_WXm80kpqEemahN0jopeFxQ"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_WXpZE0pqEemahN0jopeFxQ" partWithPort="_WXoK8UpqEemahN0jopeFxQ" role="_6YxWcA7sEem-ucXEfNJLZw"/>
        </ownedConnector>
        <ownedConnector xmi:type="uml:Connector" xmi:id="_WXpZFUpqEemahN0jopeFxQ" name="con_commands_harness_cut">
          <end xmi:type="uml:ConnectorEnd" xmi:id="_WXqAIEpqEemahN0jopeFxQ" partWithPort="_WXg2NkpqEemahN0jopeFxQ" role="_WXnj40pqEemahN0jopeFxQ"/>
          <end xmi:type="uml:ConnectorEnd" xmi:id="_WXqAIUpqEemahN0jopeFxQ" partWithPort="_WXoK8UpqEemahN0jopeFxQ" role="_WXlHoEpqEemahN0jopeFxQ"/>
        </ownedConnector>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_WXg2PUpqEemahN0jopeFxQ" name="StateMachineTOP_Test" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_WXg2PkpqEemahN0jopeFxQ" name="Region">
            <transition xmi:type="uml:Transition" xmi:id="_WXg2P0pqEemahN0jopeFxQ" name="Initial" source="_WXg2QkpqEemahN0jopeFxQ" target="_WXg2RUpqEemahN0jopeFxQ"/>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2QEpqEemahN0jopeFxQ" name="" source="_WXg2RUpqEemahN0jopeFxQ" target="_WXg2Q0pqEemahN0jopeFxQ">
              <trigger xmi:type="uml:Trigger" xmi:id="_WXg2QUpqEemahN0jopeFxQ" port="_WXg2OUpqEemahN0jopeFxQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_WXg2QkpqEemahN0jopeFxQ"/>
            <subvertex xmi:type="uml:State" xmi:id="_WXg2Q0pqEemahN0jopeFxQ" name="Starting">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2REpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>char* strategy = &quot;BFS&quot;; //default strategy
int debug=0;
int iterationLength=1;
char* heuristicStr = &quot;BFS&quot;; //default strategy
int heuristic = 0; //default algorithm for branch selection
map&lt;string,int> params;
int transitionIterations = 5; //default
int time = 0; //default time
int totalIterations = 0;
//read terminal inputs
int argc = UMLRTMain::getArgCount();
log.log(&quot;params count: %d&quot;, argc);
if (argc==1) {
  const char * arg = UMLRTMain::getArg(0);
  if (!strcmp(arg, &quot;-s&quot;)) {
      settings.start(1, &quot;conc&quot;, 30, 200, 100000, 10, 0).send(); //default 5 seconds
  }else if (!strcmp(arg, &quot;-h&quot;)){
    log.log(&quot;\n--------------------------- mcute help start ------------------------------------------\n&quot;);
    log.log(&quot;mcute [program] [config-file | config-params]\n&quot;);
    log.log(&quot;[program] : the executable program to be tested\n&quot;);
    log.log(&quot;[config-file] : a config file that describes various parameters\n&quot;);
    log.log(&quot;[config-params] : the set of parameters\n&quot;);
    log.log(&quot;example1: to execute a program called sample1 using the config file conf1, run:\nmcute sample1 conf1\n&quot;);
    log.log(&quot;example2: mcute sample1 -u conc 1 10 100 5 10 \nuses concolic execution,\nbranch negation is systematic,\n10 seconds is total execution time,\ntotal iterations are 100,\nthe longest iteration is 5 transitions,\neach transition executes for at most 10 times.\n&quot;);
    log.log(&quot;\n--------------------------- mcute help end ---------------------------------------------\n&quot;);
  }else{
    string name;
    int value;
    ifstream conf(arg);
    string comments;
    std::getline(conf, comments); //the first two lines are comments
    std::getline(conf, comments); //the first two lines are comments
    while (conf>>name>>value){
      if (name.find(&quot;//&quot;)==std::string::npos){ //line is not a comment
        params.insert(pair&lt;string,int>(name,value));
      }
    }
    cout&lt;&lt;&quot;sanity checking the config file (mcute.conf)..&quot;&lt;&lt;endl;
    assert(params.size()>=3);
    if (params[&quot;strategy&quot;]==0){
      strategy=&quot;rnd0&quot;;
    } else if (params[&quot;strategy&quot;]==1){
      strategy=&quot;black-box&quot;;
    } else if (params[&quot;strategy&quot;]==2){
      strategy=&quot;simple&quot;;
    } else if (params[&quot;strategy&quot;]==3){
      strategy=&quot;conc&quot;;
    }

    settings.start(params[&quot;heuristic&quot;], strategy, params[&quot;time&quot;], params[&quot;iterationLength&quot;] , params[&quot;totalIterations&quot;], params[&quot;transitionIterations&quot;], params[&quot;debug&quot;]).send(); //default 5 seconds
  }
}
else if (argc==6) {
  //const char * arg = UMLRTMain::getArg(0);
  //const char * arg1 = UMLRTMain::getArg(1);
  //const char * arg2 = UMLRTMain::getArg(2);
  //log.log(&quot;  0:%s, 1:%s, 2:%s  &quot; , arg, arg1, arg2);


  strategy = (char*) UMLRTMain::getArg(0);

  heuristicStr = (char*) UMLRTMain::getArg(1);

  heuristic = atoi(heuristicStr);

  const char * timeStr = UMLRTMain::getArg(2);
  time = atoi(timeStr);

  const char * totalIterationsStr = UMLRTMain::getArg(3);
  totalIterations = atoi(totalIterationsStr);

  const char * iterationLengthStr = UMLRTMain::getArg(4);
  iterationLength = atoi(iterationLengthStr);

  const char * transitionIterationsStr = UMLRTMain::getArg(5);
  if (atoi(transitionIterationsStr)>0) {
    transitionIterations = atoi(transitionIterationsStr);
  }

  settings.start(heuristic, strategy, time, iterationLength, totalIterations, transitionIterations, debug).send(); //default 5 seconds
}
</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_WXg2RUpqEemahN0jopeFxQ" name="Init">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2RkpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>timingInit.informIn(UMLRTTimespec(0.5,0));</body>
              </entry>
            </subvertex>
          </region>
        </ownedBehavior>
      </packagedElement>
      <packagedElement xmi:type="uml:Class" xmi:id="_WXg2R0pqEemahN0jopeFxQ" name="mCUTE_Harness" isActive="true">
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2SEpqEemahN0jopeFxQ" name="commands" visibility="public" type="_WXg3IkpqEemahN0jopeFxQ" isOrdered="true" aggregation="composite" isBehavior="true"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2SUpqEemahN0jopeFxQ" name="ActionCodeBranches" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2SkpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2S0pqEemahN0jopeFxQ" name="timingRunning" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2TEpqEemahN0jopeFxQ" name="log" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2TUpqEemahN0jopeFxQ" name="States" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2TkpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2T0pqEemahN0jopeFxQ" name="Transitions" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2UEpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2UUpqEemahN0jopeFxQ" name="settings" visibility="public" type="_WXg3O0pqEemahN0jopeFxQ" isOrdered="true" aggregation="composite" isBehavior="true"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2UkpqEemahN0jopeFxQ" name="next_t" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2U0pqEemahN0jopeFxQ" name="RunningTime" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2VEpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2VUpqEemahN0jopeFxQ" name="LoopBound" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2VkpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2V0pqEemahN0jopeFxQ" name="LoopExecutions" visibility="public"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2WEpqEemahN0jopeFxQ" name="VisitedBranches" visibility="public"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2WUpqEemahN0jopeFxQ" name="VisitedTransitions" visibility="public"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2WkpqEemahN0jopeFxQ" name="VisitedStates" visibility="public"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2W0pqEemahN0jopeFxQ" name="strategyObj" visibility="public"/>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2XEpqEemahN0jopeFxQ" name="TExecutions" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2XUpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2XkpqEemahN0jopeFxQ" name="Heuristic" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2X0pqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2YEpqEemahN0jopeFxQ" name="ConsecutiveTransitionsExecuted" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2YUpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2YkpqEemahN0jopeFxQ" name="ConsecutiveTransitionsPromised" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2Y0pqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2ZEpqEemahN0jopeFxQ" name="TotalIterationsPromised" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2ZUpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2ZkpqEemahN0jopeFxQ" name="TotalIterationsExecuted" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2Z0pqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2aEpqEemahN0jopeFxQ" name="Curr_State" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2aUpqEemahN0jopeFxQ" value="1"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2akpqEemahN0jopeFxQ" name="timingReport" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2a0pqEemahN0jopeFxQ" name="timingEventConsume" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2bEpqEemahN0jopeFxQ" name="Depth" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2bUpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2bkpqEemahN0jopeFxQ" name="Debug" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2b0pqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2cEpqEemahN0jopeFxQ" name="TransitionIterations" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2cUpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2ckpqEemahN0jopeFxQ" name="TransitionIterationsExecuted" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2c0pqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2dEpqEemahN0jopeFxQ" name="Constraints" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2dUpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2dkpqEemahN0jopeFxQ" name="timingReadFile" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2d0pqEemahN0jopeFxQ" name="timingRunningId" visibility="public">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2eEpqEemahN0jopeFxQ" name="timingForceTransitionId" visibility="public">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2eUpqEemahN0jopeFxQ" name="CoverageUtilObjs" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2ekpqEemahN0jopeFxQ" name="timingBFSId" visibility="public">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2e0pqEemahN0jopeFxQ" name="CoverageUtilTable" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2fEpqEemahN0jopeFxQ" name="Terminated" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:LiteralInteger" xmi:id="_WXg2fUpqEemahN0jopeFxQ" value="0"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2fkpqEemahN0jopeFxQ" name="Strategy" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2f0pqEemahN0jopeFxQ" name="timingRandomIteration" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2gEpqEemahN0jopeFxQ" name="timingForceTransition" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2gUpqEemahN0jopeFxQ" name="TestStartTime" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          <defaultValue xmi:type="uml:OpaqueExpression" xmi:id="_WXg2gkpqEemahN0jopeFxQ">
            <language>C++</language>
            <body>time(NULL)</body>
          </defaultValue>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2g0pqEemahN0jopeFxQ" name="timingBFSNextMsg" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2hEpqEemahN0jopeFxQ" name="ex" visibility="public">
          <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXg2hUpqEemahN0jopeFxQ" name="timingNewMsg" visibility="protected" isOrdered="true" aggregation="composite" isBehavior="true" isService="false">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Property" xmi:id="_WXg2hkpqEemahN0jopeFxQ" name="timingNewMsgId" visibility="public">
          <type xmi:type="uml:Class" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6qkTMGXmEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXm80EpqEemahN0jopeFxQ" name="log" isBehavior="true" isConjugated="true">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_6kIb0IeXEeSVyrlWP4nYew"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXm80kpqEemahN0jopeFxQ" name="port1" type="_jyxZ8A7sEem-ucXEfNJLZw" isBehavior="true" isConjugated="true"/>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXnj4UpqEemahN0jopeFxQ" name="timing" isBehavior="true" isConjugated="true">
          <type xmi:type="uml:Collaboration" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_MxQZgGXsEeS_4daqvwyFrg"/>
        </ownedAttribute>
        <ownedAttribute xmi:type="uml:Port" xmi:id="_WXnj40pqEemahN0jopeFxQ" name="commands" type="_WXg3IkpqEemahN0jopeFxQ" isBehavior="true"/>
        <ownedBehavior xmi:type="uml:StateMachine" xmi:id="_WXg2h0pqEemahN0jopeFxQ" name="StateMachineCuteHarness" isReentrant="false">
          <region xmi:type="uml:Region" xmi:id="_WXg2iEpqEemahN0jopeFxQ" name="Region">
            <transition xmi:type="uml:Transition" xmi:id="_WXg2iUpqEemahN0jopeFxQ" name="" source="_WXg2r0pqEemahN0jopeFxQ" target="_WXg21UpqEemahN0jopeFxQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2ikpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>RunningTime = execTime;
Strategy=strategy;
Heuristic=heuristic;
TransitionIterations = transitionIterations;
ConsecutiveTransitionsPromised = iterationLength;
Debug = debug;
if (totalIterations>0) {
	TotalIterationsPromised = totalIterations;
}
TotalIterationsExecuted=0;
log.log(&quot;\n------------------------------------------\n&quot;);
log.log (&quot;Running MCUTE with the following settings:\n&quot;);
log.log(&quot;Strategy = %s, Execution time = %d, Transition Iterations = %d, Total Iterations (for all transitions)= %d \n&quot;, strategy, RunningTime, TransitionIterations, TotalIterationsPromised);
log.log(&quot;------------------------------------------\n&quot;);
//all states, transition, branches are set statically
//States=3;
//Transitions=2;
//ActionCodeBranches=6;
//loop execution default values for all transitions with loop
//LoopExecutions[T2]=0;
//strategy = new crest::RandomSearch(&quot;&quot;, 1);
//    umlCUTE cute;
//   cute.addXXX(100,200);
//end
if (RunningTime>0) {
	timingRunningId = timingRunning.informIn(UMLRTTimespec(RunningTime,0));

}else
{
   timingRunningId = timingRunning.informIn(UMLRTTimespec(4,0));
}
//for random numbers
srand (time(NULL));
//next_t=&quot;t1&quot;;
//Curr_State=INIT;



</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_WXg2i0pqEemahN0jopeFxQ" event="_WXg3TEpqEemahN0jopeFxQ" port="_WXg2UUpqEemahN0jopeFxQ"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2jEpqEemahN0jopeFxQ" source="_WXg2rEpqEemahN0jopeFxQ" target="_WXg2sEpqEemahN0jopeFxQ"/>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2jUpqEemahN0jopeFxQ" name="" source="_WXg2sEpqEemahN0jopeFxQ" target="_WXg2r0pqEemahN0jopeFxQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2jkpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>CreateCoverageUtilTable();
//transition_util::create_coverage_util(CoverageUtilTable);</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_WXg2j0pqEemahN0jopeFxQ" event="_WXg3NUpqEemahN0jopeFxQ" port="_WXg2SEpqEemahN0jopeFxQ"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2kEpqEemahN0jopeFxQ" name="" guard="_WXg2kUpqEemahN0jopeFxQ" source="_WXg21UpqEemahN0jopeFxQ" target="_WXg2skpqEemahN0jopeFxQ">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_WXg2kUpqEemahN0jopeFxQ">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_WXg2kkpqEemahN0jopeFxQ">
                  <language>C++</language>
                  <body>return Strategy==&quot;rnd0&quot; || Strategy==&quot;random0&quot; || Strategy==&quot;r0&quot; || Strategy==&quot;RND0&quot; || Strategy==&quot;RANDOM0&quot; || Strategy==&quot;R0&quot;;
//return Strategy==&quot;SMP&quot; || Strategy==&quot;smp&quot; || Strategy==&quot;simple&quot; || Strategy==&quot;SIMPLE&quot; || Strategy==&quot;S&quot; || Strategy==&quot;s&quot;;</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2k0pqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>//writing strategy to a file
fileutil::writeData(&quot;strategy&quot;, &quot;0&quot;);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2lEpqEemahN0jopeFxQ" name="" source="_WXg2sUpqEemahN0jopeFxQ" target="_WXg2rUpqEemahN0jopeFxQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2lUpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>log.log (&quot;\n---- test execution timeout-----\n&quot;);</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_WXg2lkpqEemahN0jopeFxQ" port="_WXg2S0pqEemahN0jopeFxQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2l0pqEemahN0jopeFxQ" name="Max_Transition_Exec_Reached" source="_WXg2s0pqEemahN0jopeFxQ" target="_WXg2rUpqEemahN0jopeFxQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2mEpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>//cancel the other timer
timingRunning.cancelTimer(timingRunningId);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2mUpqEemahN0jopeFxQ" guard="_WXg2mkpqEemahN0jopeFxQ" source="_WXg21UpqEemahN0jopeFxQ" target="_WXg210pqEemahN0jopeFxQ">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_WXg2mkpqEemahN0jopeFxQ">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_WXg2m0pqEemahN0jopeFxQ">
                  <language>C++</language>
                  <body>return Strategy==&quot;conc&quot; || Strategy==&quot;CONC&quot; || Strategy==&quot;C&quot; || Strategy==&quot;c&quot;;</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2nEpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>//writing strategy to a file
fileutil::writeData(&quot;strategy&quot;, &quot;2&quot;);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2nUpqEemahN0jopeFxQ" name="" source="_WXg21kpqEemahN0jopeFxQ" target="_WXg2rUpqEemahN0jopeFxQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2nkpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>timingBFSNextMsg.cancelTimer(timingBFSId);</body>
              </effect>
              <trigger xmi:type="uml:Trigger" xmi:id="_WXg2n0pqEemahN0jopeFxQ" port="_WXg2S0pqEemahN0jopeFxQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2oEpqEemahN0jopeFxQ" name="Collect_Extra_Events_No_Chance_Exec" source="_WXg2rUpqEemahN0jopeFxQ" target="_WXg29EpqEemahN0jopeFxQ">
              <trigger xmi:type="uml:Trigger" xmi:id="_WXg2oUpqEemahN0jopeFxQ" event="_WXg3NUpqEemahN0jopeFxQ" port="_WXg2SEpqEemahN0jopeFxQ"/>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2okpqEemahN0jopeFxQ" name="Max_Transition_Exec_Reached3" source="_WXg290pqEemahN0jopeFxQ" target="_WXg2rUpqEemahN0jopeFxQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2o0pqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>//cancel the other timer
timingRunning.cancelTimer(timingRunningId);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2pEpqEemahN0jopeFxQ" guard="_WXg2pUpqEemahN0jopeFxQ" source="_WXg21UpqEemahN0jopeFxQ" target="_WXg29kpqEemahN0jopeFxQ">
              <ownedRule xmi:type="uml:Constraint" xmi:id="_WXg2pUpqEemahN0jopeFxQ">
                <specification xmi:type="uml:OpaqueExpression" xmi:id="_WXg2pkpqEemahN0jopeFxQ">
                  <language>C++</language>
                  <body>//return Strategy==&quot;rnd1&quot; || Strategy==&quot;random1&quot; || Strategy==&quot;r1&quot; || Strategy==&quot;RND1&quot; || Strategy==&quot;RANDOM1&quot; || Strategy==&quot;R1&quot;;
//return Strategy==&quot;SMP&quot; || Strategy==&quot;smp&quot; || Strategy==&quot;simple&quot; || Strategy==&quot;SIMPLE&quot; || Strategy==&quot;S&quot; || Strategy==&quot;s&quot;;
return Strategy==&quot;simple&quot; || Strategy==&quot;black-box&quot;;</body>
                </specification>
              </ownedRule>
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2p0pqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>//writing strategy to a file
fileutil::writeData(&quot;strategy&quot;, &quot;1&quot;);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2qEpqEemahN0jopeFxQ" name="Max_Transition_Exec_Reached2" source="_WXg22EpqEemahN0jopeFxQ" target="_WXg2rUpqEemahN0jopeFxQ">
              <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2qUpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                <language>C++</language>
                <body>//cancel the other timer
timingRunning.cancelTimer(timingRunningId);</body>
              </effect>
            </transition>
            <transition xmi:type="uml:Transition" xmi:id="_WXg2qkpqEemahN0jopeFxQ" name="" source="_WXg29UpqEemahN0jopeFxQ" target="_WXg2rUpqEemahN0jopeFxQ">
              <trigger xmi:type="uml:Trigger" xmi:id="_WXg2q0pqEemahN0jopeFxQ" port="_WXg2S0pqEemahN0jopeFxQ">
                <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
              </trigger>
            </transition>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_WXg2rEpqEemahN0jopeFxQ"/>
            <subvertex xmi:type="uml:State" xmi:id="_WXg2rUpqEemahN0jopeFxQ" name="Reporting">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2rkpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>//calculating branch coverage
int totalBranches=0;
int totalCovered=0;
map&lt;string, coverage_util*>::iterator it;
for (it=CoverageUtilTable.begin();it!=CoverageUtilTable.end();it++){
	totalBranches+=it->second->branches_.size();
	totalCovered+=it->second->total_num_covered_;
}

int allVisitedTransitions=VisitedTransitions.size()+1;
int allVisitedStates= VisitedStates.size()+1;

log.log(&quot;\n=============== Test execution report ===============&quot;);
log.log(&quot;\n     Total test execution time: %d (seconds)   &quot;, time(NULL) - TestStartTime);
log.log(&quot;\n     Total executed test iterations: %d   &quot;, TotalIterationsExecuted);
log.log(&quot;\n     Total Branch coverage: %d out of %d = %%%.1f   &quot;, totalCovered, totalBranches, (float)totalCovered/totalBranches*100);
log.log(&quot;\n     Transition coverage: %d out of %d = %%%.1f   &quot;, allVisitedTransitions, Transitions, (float)allVisitedTransitions/Transitions * 100);
log.log(&quot;\n     State coverage: %d out of %d = %%%.1f   &quot;, allVisitedStates, States, (float)allVisitedStates/States * 100);
log.log(&quot;\n=====================================================&quot;);
</body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_WXg2r0pqEemahN0jopeFxQ" name="Starting"/>
            <subvertex xmi:type="uml:State" xmi:id="_WXg2sEpqEemahN0jopeFxQ" name="Init">
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WX0YMEpqEemahN0jopeFxQ">
                <language>C++</language>
                <body>
 next_t=&quot;t1&quot;;
 Curr_State = 1;
 States=6;
 Transitions=6;
  </body>
              </entry>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_WXg2sUpqEemahN0jopeFxQ" name="Random__Random0__Testing1">
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_WXg2skpqEemahN0jopeFxQ" kind="entryPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_WXg2s0pqEemahN0jopeFxQ" kind="exitPoint"/>
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2tEpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>//selecting the next transition
//transition_util::select_next_transition(Curr_State, next_t, VisitedTransitions);
SelectNextTransition();

//initialize the coverage info object for the transition
//CoverageInfo.transition = next_t;
//coverage_util cu(next_t);
//cu.initCoverageInfo();
//CoverageUtilObjs.push_back(cu);
</body>
              </entry>
              <region xmi:type="uml:Region" xmi:id="_WXg2tUpqEemahN0jopeFxQ" name="Region1">
                <transition xmi:type="uml:Transition" xmi:id="_WXg2tkpqEemahN0jopeFxQ" kind="local" source="_WXg2skpqEemahN0jopeFxQ" target="_WXg2yEpqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2t0pqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>TransitionIterationsExecuted=0;
TotalIterationsExecuted=0;
TExecutions=0;
log.log(&quot;\nTotalIterationsPromised:%d, TotalIterationsExecuted:%d\n&quot;, TotalIterationsPromised, TransitionIterationsExecuted);</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg2uEpqEemahN0jopeFxQ" name="TransitionExecuted" source="_WXg2yEpqEemahN0jopeFxQ" target="_WXg2ykpqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2uUpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//cancel the timer since the transition was executed
timingForceTransition.cancelTimer(timingForceTransitionId);

TransitionIterationsExecuted++;
TotalIterationsExecuted++;</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg2ukpqEemahN0jopeFxQ" event="_WXg3NUpqEemahN0jopeFxQ" port="_WXg2SEpqEemahN0jopeFxQ"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg2u0pqEemahN0jopeFxQ" name="NewIteration" source="_WXg2ykpqEemahN0jopeFxQ" target="_WXg2yEpqEemahN0jopeFxQ">
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg2vEpqEemahN0jopeFxQ" event="_WXg3NUpqEemahN0jopeFxQ" port="_WXg2SEpqEemahN0jopeFxQ"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg2vUpqEemahN0jopeFxQ" name="" source="_WXg2ykpqEemahN0jopeFxQ" target="_WXg2zEpqEemahN0jopeFxQ">
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg2vkpqEemahN0jopeFxQ" port="_WXg2f0pqEemahN0jopeFxQ">
                    <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
                  </trigger>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg2v0pqEemahN0jopeFxQ" name="Select_Candidate_Transition_for_Execution" source="_WXg2zEpqEemahN0jopeFxQ" target="_WXg2yEpqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2wEpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>log.log(&quot;\nexecuting next transition: %s\n&quot;, next_t.c_str());

//transition_util::select_next_transition(Curr_State, next_t, VisitedTransitions);
SelectNextTransition();

    //initialize the coverage info object for the transition
    //CoverageInfo.transition = next_t;
//    coverage_util cu(next_t);
//    cu.initCoverageInfo();
//    CoverageUtilObjs.push_back(cu);</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg2wUpqEemahN0jopeFxQ" guard="_WXg2wkpqEemahN0jopeFxQ" source="_WXg2zEpqEemahN0jopeFxQ" target="_WXg2s0pqEemahN0jopeFxQ">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_WXg2wkpqEemahN0jopeFxQ">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_WXg2w0pqEemahN0jopeFxQ">
                      <language>C++</language>
                      <body>//whether or not the search budget is over, or whether or not all the transitions were already visited
return (TotalIterationsPromised > 0 &amp;&amp; TotalIterationsExecuted >= TotalIterationsPromised) 
|| (find(VisitedTransitions.begin(), VisitedTransitions.end(), &quot;t1&quot;)!=VisitedTransitions.end() &amp;&amp; 
   find(VisitedTransitions.begin(), VisitedTransitions.end(), &quot;t2&quot;)!=VisitedTransitions.end() );</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2xEpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>log.log(&quot;\nenough transitions were executed\n&quot;);</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg2xUpqEemahN0jopeFxQ" name="Keep_Sending_New_Msgs_To_Force_Exec" source="_WXg2yEpqEemahN0jopeFxQ" target="_WXg2ykpqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2xkpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>log.log (&quot;transition [%s] was not fired since its gaurd predicate did not hold. Trying again..&quot;, next_t.c_str());</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg2x0pqEemahN0jopeFxQ" port="_WXg2gEpqEemahN0jopeFxQ">
                    <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
                  </trigger>
                </transition>
                <subvertex xmi:type="uml:State" xmi:id="_WXg2yEpqEemahN0jopeFxQ" name="SendMessage">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2yUpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>//generating data
//generating 10 data
vector&lt;value_t> inputs;
data_generator::generateInteger(10, inputs);

//saving to a file so the action code can restore them from there
fileutil::writeInputs(&quot;input&quot;, inputs);

//send message to the current transition
SendNextMessage();

//TODO: pursue this issue
//if the transition is not executed normally, retart to send a new message in the next iteration
//timingForceTransitionId = timingForceTransition.informIn(UMLRTTimespec(0.2,0));
</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_WXg2ykpqEemahN0jopeFxQ" name="Prepare4NextIteration">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2y0pqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>//keep track of visited states
if (rtdata){
	//Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
	Curr_State = *((int*) rtdata);
	if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	  VisitedStates.push_back(Curr_State);
	}
}
//reading SE object
SymbolicExecution ex;
std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
ex.Parse(in);
in.close();

//updating the coverage information
//printf (&quot;\n[[vector size=%d]]\n&quot;, CoverageUtilObjs.size());
coverage_util* it = CoverageUtilTable[next_t];
it->incIterations();
it->updateCoverageInfo(ex);


if (TransitionIterationsExecuted&lt;TransitionIterations)
{
  //go back to previous state to be able to send new inputs
  //restarting
  commands.reset().send();
}else{
  if (TExecutions&lt;Transitions){
    log.log(&quot;\nchanging the transition\n&quot;);
    TExecutions++;
    
    timingRandomIteration.informIn(UMLRTTimespec(0,100));
    TransitionIterationsExecuted=0;
  }
}
</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_WXg2zEpqEemahN0jopeFxQ" kind="choice"/>
                <subvertex xmi:type="uml:State" xmi:id="_WXg2zUpqEemahN0jopeFxQ" name="Random__SimEXP__Testing">
                  <region xmi:type="uml:Region" xmi:id="_WXg2zkpqEemahN0jopeFxQ" name="Region1">
                    <transition xmi:type="uml:Transition" xmi:id="_WXg2z0pqEemahN0jopeFxQ" name="Keep_Sending_New_Msgs_To_Force_Exec" source="_WXg20EpqEemahN0jopeFxQ" target="_WXg20kpqEemahN0jopeFxQ"/>
                    <subvertex xmi:type="uml:State" xmi:id="_WXg20EpqEemahN0jopeFxQ" name="SendMessage">
                      <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg20UpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                        <language>C++</language>
                        <body>//generating data
//int imin = std::numeric_limits&lt;int>::min(); // min int value
//int imax = std::numeric_limits&lt;int>::max(); //max int value
//TODO: fix this to generate numbers between ranges uniforly using a c++ library
//int inp1 = rand() % imax + imin;
int inp1 = rand() % 300000 + (-100000);
int inp2 = rand() % 300000 + (-100000);
int inp3 = rand() % 300000 + (-100000);
int inp4 = rand() % 300000 + (-100000);
printf(&quot;\ninputs generated by the harness (in random inp gen): %d, %d, %d, %d\n&quot;,inp1,inp2,inp3,inp4 );
vector&lt;value_t> inputs;
inputs.push_back(inp1);
inputs.push_back(inp2);
inputs.push_back(inp3);
inputs.push_back(inp4);

//saving to a file so the action code can restore them from there
fileutil::writeInputs(&quot;input&quot;, inputs);

//send message to the current transition
SendNextMessage();

//TODO: pursue this issue
//if the transition is not executed normally, retart to send a new message in the next iteration
//timingForceTransitionId = timingForceTransition.informIn(UMLRTTimespec(0.2,0));
</body>
                      </entry>
                    </subvertex>
                    <subvertex xmi:type="uml:State" xmi:id="_WXg20kpqEemahN0jopeFxQ" name="Prepare4NextIteration">
                      <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg200pqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                        <language>C++</language>
                        <body>//keep track of visited states
if (rtdata){
	Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
	if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	  VisitedStates.push_back(Curr_State);
	}
}
//reading SE object
SymbolicExecution ex;
std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
ex.Parse(in);
in.close();

//updating the coverage information
//printf (&quot;\n[[vector size=%d]]\n&quot;, CoverageUtilObjs.size());
coverage_util* it = CoverageUtilTable[next_t];
it->incIterations();
it->updateCoverageInfo(ex);


if (TransitionIterationsExecuted&lt;TransitionIterations)
{
  //restarting
  commands.reset().send();
}else{
  //go back to previous state to be able to send new inputs
  if (TExecutions&lt;Transitions){
    log.log(&quot;\nchanging the transition\n&quot;);
    TExecutions++;
    
    timingRandomIteration.informIn(UMLRTTimespec(0,100));
    TransitionIterationsExecuted=0;
  }
}
</body>
                      </entry>
                    </subvertex>
                    <subvertex xmi:type="uml:Pseudostate" xmi:id="_WXg21EpqEemahN0jopeFxQ" kind="choice"/>
                  </region>
                </subvertex>
              </region>
            </subvertex>
            <subvertex xmi:type="uml:Pseudostate" xmi:id="_WXg21UpqEemahN0jopeFxQ" kind="choice"/>
            <subvertex xmi:type="uml:State" xmi:id="_WXg21kpqEemahN0jopeFxQ" name="Concolic__BFS__DFS_Testing">
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_WXg210pqEemahN0jopeFxQ" kind="entryPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_WXg22EpqEemahN0jopeFxQ" kind="exitPoint"/>
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg22UpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>
//*****************************************************************
//**** deciding what is the next transition to be executed ********
//*****************************************************************

log.log (&quot;--- \n Selecting the next transition for execution ----\n&quot;);

//keep track of visited states
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
  VisitedStates.push_back(Curr_State);
}


//Selecting next transition
//transition_util::select_next_transition(Curr_State, next_t, VisitedTransitions);
SelectNextTransition();
</body>
              </entry>
              <region xmi:type="uml:Region" xmi:id="_WXg22kpqEemahN0jopeFxQ" name="Region1">
                <transition xmi:type="uml:Transition" xmi:id="_WXg220pqEemahN0jopeFxQ" kind="local" source="_WXg210pqEemahN0jopeFxQ" target="_WXg27UpqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg23EpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//ConsecutiveTransitionsPromised=2;
ConsecutiveTransitionsExecuted=0;
TotalIterationsExecuted=0;
Depth=0;</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg23UpqEemahN0jopeFxQ" name="Transition_Executed" source="_WXg27UpqEemahN0jopeFxQ" target="_WXg270pqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg23kpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//cancelling the timer set for sending a new message (due to an unexpected message generated by the harness)
//timingNewMsg.cancelTimer(timingNewMsgId);

//keep track of visited states
//int s=*((int*) rtdata);
//printf (&quot;state recived by harness:%d&quot;, s);
//Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
Curr_State = *((int*) rtdata);
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	VisitedStates.push_back(Curr_State);
}

//updating the visited transitions
//since here we know that the transitions
//has executed on the CUT
if(std::find(VisitedTransitions.begin(), VisitedTransitions.end(), next_t) == VisitedTransitions.end()){
  VisitedTransitions.push_back(next_t);
}

ConsecutiveTransitionsExecuted++;
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg230pqEemahN0jopeFxQ" event="_WXg3NUpqEemahN0jopeFxQ" port="_WXg2SEpqEemahN0jopeFxQ"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg24EpqEemahN0jopeFxQ" name="timeout/Execute_Next_Transition" source="_WXg270pqEemahN0jopeFxQ" target="_WXg27UpqEemahN0jopeFxQ">
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg24UpqEemahN0jopeFxQ" port="_WXg2g0pqEemahN0jopeFxQ">
                    <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
                  </trigger>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg24kpqEemahN0jopeFxQ" name="nextState/updateCoverage" source="_WXg28UpqEemahN0jopeFxQ" target="_WXg27UpqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg240pqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//keep track of visited states

</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg25EpqEemahN0jopeFxQ" event="_WXg3NUpqEemahN0jopeFxQ" port="_WXg2SEpqEemahN0jopeFxQ"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg25UpqEemahN0jopeFxQ" name="New_Iteration_Initiated/Negate_Solve_Constraint" guard="_WXg25kpqEemahN0jopeFxQ" source="_WXg280pqEemahN0jopeFxQ" target="_WXg27UpqEemahN0jopeFxQ">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_WXg25kpqEemahN0jopeFxQ">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_WXg250pqEemahN0jopeFxQ">
                      <language>C++</language>
                      <body>return (TotalIterationsExecuted &lt; TotalIterationsPromised) &amp;&amp; !AllBranchesCovered();</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg26EpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//keep track of visited states
//Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
	Curr_State = *((int*) rtdata);
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	VisitedStates.push_back(Curr_State);
}

//transition_util::select_next_transition(Curr_State, next_t, VisitedTransitions);
SelectNextTransition();

if (Heuristic==0){ //random branch selection
	branch_util::negate_rand(ex, Depth);
}else{
	branch_util::negate_sys(ex, Depth, CoverageUtilTable, next_t);
}

</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg26UpqEemahN0jopeFxQ" name="" source="_WXg270pqEemahN0jopeFxQ" target="_WXg280pqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg26kpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>TotalIterationsExecuted++;
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg260pqEemahN0jopeFxQ" event="_WXg3NUpqEemahN0jopeFxQ" port="_WXg2SEpqEemahN0jopeFxQ"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg27EpqEemahN0jopeFxQ" source="_WXg280pqEemahN0jopeFxQ" target="_WXg22EpqEemahN0jopeFxQ"/>
                <subvertex xmi:type="uml:State" xmi:id="_WXg27UpqEemahN0jopeFxQ" name="MsgSending">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg27kpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>SendNextMessage();

//it is possible that the model under test cannot consume a particular message
//so the harness waits for a short while before sending a new possibly different message
//timingNewMsgId = timingNewMsg.informIn(UMLRTTimespec(0,100000));

cout &lt;&lt;endl&lt;&lt; &quot;================================================================================&quot; &lt;&lt;endl;
cout &lt;&lt; &quot;\t\t\tExecuting the transition: &quot; &lt;&lt; next_t.c_str() &lt;&lt; endl;
cout &lt;&lt; &quot;================================================================================&quot; &lt;&lt;endl&lt;&lt;endl;


</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_WXg270pqEemahN0jopeFxQ" name="MsgRecieved">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg28EpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>//reading SE object
//SymbolicExecution ex;
std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
ex.Parse(in);
in.close();

Constraints = ex.path().constraints().size();
log.log (&quot;Harness: Depth is: %d, Constraints are:%d\n&quot;, Depth, Constraints);

if (Debug){
  //print SE object info
  fileutil::printSymExObj(false, true, false);
}

//updating the coverage information
//coverage_util* it = CoverageUtilTable[next_t];
//it->incIterations();
//it->updateCoverageInfo(ex);
map&lt;string, coverage_util*>::iterator it = CoverageUtilTable.find(next_t);
coverage_util* coverageUtil;
if (it!=CoverageUtilTable.end()){
   coverageUtil = it->second;
   coverageUtil->incIterations();
   coverageUtil->updateCoverageInfo(ex);
}


//new iteration
if (ConsecutiveTransitionsExecuted>=ConsecutiveTransitionsPromised){
  log.log(&quot;\nHarness: new iteration, restarting\n&quot;);
  commands.iterate().send();
  ConsecutiveTransitionsExecuted=0;
  // TExecutions=0;
}
else{
  // TExecutions++;
  //next message by the Harness
	timingBFSId = timingBFSNextMsg.informIn(UMLRTTimespec(0,100));
}



SelectNextTransition();
//transition_util::select_next_transition(Curr_State, next_t, VisitedTransitions);</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_WXg28UpqEemahN0jopeFxQ" name="__InitialMsgSent__">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg28kpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>

//-------------------------------------------------
//---- generate and send random data --------------
//---- to the selected transition -----------------
//-------------------------------------------------
cout&lt;&lt;&quot;------------------------------------------&quot; &lt;&lt;endl;
cout&lt;&lt;&quot;--------- executing the transition: &quot; &lt;&lt; next_t &lt;&lt;endl;
cout&lt;&lt;&quot;------------------------------------------&quot; &lt;&lt;endl;



</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_WXg280pqEemahN0jopeFxQ" kind="choice"/>
              </region>
            </subvertex>
            <subvertex xmi:type="uml:State" xmi:id="_WXg29EpqEemahN0jopeFxQ" name="Done"/>
            <subvertex xmi:type="uml:State" xmi:id="_WXg29UpqEemahN0jopeFxQ" name="Random__SimpleEx_BlackBox__Testing">
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_WXg29kpqEemahN0jopeFxQ" kind="entryPoint"/>
              <connectionPoint xmi:type="uml:Pseudostate" xmi:id="_WXg290pqEemahN0jopeFxQ" kind="exitPoint"/>
              <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2-EpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                <language>C++</language>
                <body>
//*****************************************************************
//**** deciding what is the next transition to be executed ********
//*****************************************************************

log.log (&quot;--- \n Selecting the next transition for execution ----\n&quot;);

//keep track of visited states
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
  VisitedStates.push_back(Curr_State);
}

</body>
              </entry>
              <region xmi:type="uml:Region" xmi:id="_WXg2-UpqEemahN0jopeFxQ" name="Region1">
                <transition xmi:type="uml:Transition" xmi:id="_WXg2-kpqEemahN0jopeFxQ" kind="local" source="_WXg29kpqEemahN0jopeFxQ" target="_WXg3C0pqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2-0pqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//ConsecutiveTransitionsPromised=2;
ConsecutiveTransitionsExecuted=0;
TotalIterationsExecuted=0;
Depth=0;</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg2_EpqEemahN0jopeFxQ" name="Transition_Executed" source="_WXg3C0pqEemahN0jopeFxQ" target="_WXg3DUpqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg2_UpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//cancelling the timer set for sending a new message (due to an unexpected message generated by the harness)
timingNewMsg.cancelTimer(timingNewMsgId);

//keep track of visited states
//Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
	Curr_State = *((int*) rtdata);
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	VisitedStates.push_back(Curr_State);
}

//updating the visited transitions
//since here we know that the transitions
//has executed on the CUT
if(std::find(VisitedTransitions.begin(), VisitedTransitions.end(), next_t) == VisitedTransitions.end()){
  VisitedTransitions.push_back(next_t);
}

ConsecutiveTransitionsExecuted++;


</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg2_kpqEemahN0jopeFxQ" event="_WXg3NUpqEemahN0jopeFxQ" port="_WXg2SEpqEemahN0jopeFxQ"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg2_0pqEemahN0jopeFxQ" name="timeout/Execute_Next_Transition" source="_WXg3DUpqEemahN0jopeFxQ" target="_WXg3C0pqEemahN0jopeFxQ">
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg3AEpqEemahN0jopeFxQ" port="_WXg2g0pqEemahN0jopeFxQ">
                    <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
                  </trigger>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg3AUpqEemahN0jopeFxQ" name="Execute_New_Iteration" guard="_WXg3AkpqEemahN0jopeFxQ" source="_WXg3D0pqEemahN0jopeFxQ" target="_WXg3C0pqEemahN0jopeFxQ">
                  <ownedRule xmi:type="uml:Constraint" xmi:id="_WXg3AkpqEemahN0jopeFxQ">
                    <specification xmi:type="uml:OpaqueExpression" xmi:id="_WXg3A0pqEemahN0jopeFxQ">
                      <language>C++</language>
                      <body>return (TotalIterationsExecuted &lt; TotalIterationsPromised) &amp;&amp; !AllBranchesCovered();</body>
                    </specification>
                  </ownedRule>
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg3BEpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>//keep track of visited states
//Curr_State = static_cast&lt;STATES>(*((int*) rtdata));
	Curr_State = *((int*) rtdata);
if(std::find(VisitedStates.begin(), VisitedStates.end(), Curr_State) == VisitedStates.end()){
	VisitedStates.push_back(Curr_State);
}

//transition_util::select_next_transition(Curr_State, next_t, VisitedTransitions);
SelectNextTransition();



</body>
                  </effect>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg3BUpqEemahN0jopeFxQ" name="" source="_WXg3DUpqEemahN0jopeFxQ" target="_WXg3D0pqEemahN0jopeFxQ">
                  <effect xmi:type="uml:OpaqueBehavior" xmi:id="_WXg3BkpqEemahN0jopeFxQ" name="Effect" isReentrant="false">
                    <language>C++</language>
                    <body>TotalIterationsExecuted++;
</body>
                  </effect>
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg3B0pqEemahN0jopeFxQ" event="_WXg3NUpqEemahN0jopeFxQ" port="_WXg2SEpqEemahN0jopeFxQ"/>
                </transition>
                <transition xmi:type="uml:Transition" xmi:id="_WXg3CEpqEemahN0jopeFxQ" source="_WXg3D0pqEemahN0jopeFxQ" target="_WXg290pqEemahN0jopeFxQ"/>
                <transition xmi:type="uml:Transition" xmi:id="_WXg3CUpqEemahN0jopeFxQ" name="Message_Was_UnExpected_Send_New_One" source="_WXg3C0pqEemahN0jopeFxQ" target="_WXg3C0pqEemahN0jopeFxQ">
                  <trigger xmi:type="uml:Trigger" xmi:id="_WXg3CkpqEemahN0jopeFxQ" port="_WXg2hUpqEemahN0jopeFxQ">
                    <event xmi:type="uml:CallEvent" href="pathmap://UMLRTRTSLIB/UMLRT-RTS.uml#_IaEO8HDxEeSwWKwNKw1iAA"/>
                  </trigger>
                </transition>
                <subvertex xmi:type="uml:State" xmi:id="_WXg3C0pqEemahN0jopeFxQ" name="MsgSending">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg3DEpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>SelectNextTransition();
//transition_util::select_next_transition(Curr_State, next_t, VisitedTransitions, Strategy);

//generating 10 data
vector&lt;value_t> inputs;
data_generator::generateInteger(10, inputs);

//saving to a file so the action code can restore them from there
fileutil::writeInputs(&quot;input&quot;, inputs);

SendNextMessage();

//it is possible that the model under test cannot consume a particular message
//so the harness waits for a short while before sending a new possibly different message
timingNewMsgId = timingNewMsg.informIn(UMLRTTimespec(0,30000000));

cout &lt;&lt;endl&lt;&lt; &quot;================================================================================&quot; &lt;&lt;endl;
cout &lt;&lt; &quot;\t\t\tExecuting the transition: &quot; &lt;&lt; next_t.c_str() &lt;&lt; endl;
cout &lt;&lt; &quot;================================================================================&quot; &lt;&lt;endl&lt;&lt;endl;


</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:State" xmi:id="_WXg3DUpqEemahN0jopeFxQ" name="MsgRecieved">
                  <entry xmi:type="uml:OpaqueBehavior" xmi:id="_WXg3DkpqEemahN0jopeFxQ" name="Entry" isReentrant="false">
                    <language>C++</language>
                    <body>//reading SE object
//SymbolicExecution ex;
std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
ex.Parse(in);
in.close();


//updating the coverage information
//coverage_util* it = CoverageUtilTable[next_t];
//it->incIterations();
//it->updateCoverageInfo(ex);
map&lt;string, coverage_util*>::iterator it = CoverageUtilTable.find(next_t);
coverage_util* coverageUtil;
if (it!=CoverageUtilTable.end()){
   coverageUtil = it->second;
   coverageUtil->incIterations();
   coverageUtil->updateCoverageInfo(ex);
}




//new iteration
if (ConsecutiveTransitionsExecuted>=ConsecutiveTransitionsPromised){
  log.log(&quot;\nnew iteration,restarting\n&quot;);
  commands.iterate().send();
  ConsecutiveTransitionsExecuted=0;
  // TExecutions=0;
}
else{
  // TExecutions++;
  //next message by the Harness
	timingBFSId = timingBFSNextMsg.informIn(UMLRTTimespec(0,100));
}

SelectNextTransition();
//transition_util::select_next_transition(Curr_State, next_t, VisitedTransitions, Strategy);</body>
                  </entry>
                </subvertex>
                <subvertex xmi:type="uml:Pseudostate" xmi:id="_WXg3D0pqEemahN0jopeFxQ" kind="choice"/>
              </region>
            </subvertex>
          </region>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_WXg3EEpqEemahN0jopeFxQ" name="DFSOpaqueBehavior" specification="_WXg3GkpqEemahN0jopeFxQ">
          <language>C++</language>
          <body>std::cout&lt;&lt;&quot;DFS CALLED, depth:&quot;&lt;&lt;depth&lt;&lt;std::endl;
/* UMLRTGEN-USERREGION-BEGIN platform:/resource/MCUTE/Harness_UMLRT/Harness2.uml mCUTE::CUTE_Harness operation DFS */
SymbolicExecution cur_ex;
vector&lt;value_t> input;
const SymbolicPath&amp; path = prev_ex.path();
for (size_t i = pos; (i &lt; path.constraints().size()) &amp;&amp; (depth > 0); i++) {
	// Solve constraints[0..i].
	if (!SolveAtBranch(prev_ex, i, input)) {
		std::cout&lt;&lt;&quot;could not solve depth: &quot;&lt;&lt;i&lt;&lt;std::endl;
		continue;
	}
	// Run on those constraints.
	//data.setup(0,0).send();
	commands.reset().send();
	//read the SE object after transition execution
	std::ifstream in(&quot;szd_execution&quot;, std::ios::in | std::ios::binary);
	cur_ex.Parse(in);
	in.close();
	//UpdateCoverage(cur_ex);
	// We successfully solved the branch, recurse.
	depth--;
	DFS(i+1, depth, cur_ex);
}</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_WXg3EUpqEemahN0jopeFxQ" name="SolveAtBranchOpaqueBehavior" specification="_WXg3FUpqEemahN0jopeFxQ">
          <language>C++</language>
          <body>const vector&lt;SymbolicPred*>&amp; constraints = ex.path().constraints();

	// Optimization: If any of the previous constraints are idential to the
	// branch_idx-th constraint, immediately return false.
	for (int i = static_cast&lt;int>(branch_idx) - 1; i >= 0; i--) {
		if (constraints[branch_idx]->Equal(*constraints[i]))
			return false;
	}

	vector&lt;const SymbolicPred*> cs(constraints.begin(),
			constraints.begin() + branch_idx + 1);
	map&lt;var_t, value_t> soln;
	constraints[branch_idx]->Negate();
	// fprintf(stderr, &quot;Yices . . . &quot;);
	bool success = YicesSolver::IncrementalSolve(ex.inputs(), ex.vars(), cs,
			&amp;soln);
	// fprintf(stderr, &quot;%d\n&quot;, success);
	constraints[branch_idx]->Negate();

	if (success) {
		// Merge the solution with the previous input to get the next
		// input.  (Could merge with random inputs, instead.)
		input = ex.inputs();
		// RandomInput(ex.vars(), input);

		typedef map&lt;var_t, value_t>::const_iterator SolnIt;
		for (SolnIt i = soln.begin(); i != soln.end(); ++i) {
			input[i->first] = i->second;
		}
		return true;
	}

	return false;
</body>
        </ownedBehavior>
        <ownedBehavior xmi:type="uml:OpaqueBehavior" xmi:id="_WXg3EkpqEemahN0jopeFxQ" name="AllBranchesCoveredOpaqueBehavior" specification="_WXg3E0pqEemahN0jopeFxQ">
          <language>C++</language>
          <body>map&lt;string, coverage_util*>::iterator it;
bool allCoverred=true;
for (it=CoverageUtilTable.begin();it!=CoverageUtilTable.end();it++){
  if (it->second->total_num_covered_&lt;it->second->branches_.size()){
    allCoverred=false;
  }
}
return allCoverred;</body>
        </ownedBehavior>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3E0pqEemahN0jopeFxQ" name="AllBranchesCovered" concurrency="guarded" method="_WXg3EkpqEemahN0jopeFxQ">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3FEpqEemahN0jopeFxQ" name="allCovered" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_vAIV4I7PEdySGvm5GN66HA"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3FUpqEemahN0jopeFxQ" name="SolveAtBranch" concurrency="guarded" method="_WXg3EUpqEemahN0jopeFxQ">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3FkpqEemahN0jopeFxQ" name="result" direction="return">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Boolean"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3F0pqEemahN0jopeFxQ" name="ex">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3GEpqEemahN0jopeFxQ" name="branch_idx">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3GUpqEemahN0jopeFxQ" name="input">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3GkpqEemahN0jopeFxQ" name="DFS" concurrency="guarded" method="_WXg3EEpqEemahN0jopeFxQ">
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3G0pqEemahN0jopeFxQ" name="pos">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3HEpqEemahN0jopeFxQ" name="depth">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
          <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3HUpqEemahN0jopeFxQ" name="prev_ex">
            <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
          </ownedParameter>
        </ownedOperation>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3HkpqEemahN0jopeFxQ" name="SelectNextTransition" concurrency="guarded" method="_WXwt0EpqEemahN0jopeFxQ"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3H0pqEemahN0jopeFxQ" name="SendNextMessage" concurrency="guarded" method="_WXuRkEpqEemahN0jopeFxQ"/>
        <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3IEpqEemahN0jopeFxQ" name="CreateCoverageUtilTable" concurrency="guarded" method="_WXyjAEpqEemahN0jopeFxQ"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_WXg3IUpqEemahN0jopeFxQ" name="mCUTE_Commands">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_WXg3IkpqEemahN0jopeFxQ" name="mCUTE_Commands">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_WXj5j0pqEemahN0jopeFxQ" client="_WXg3IkpqEemahN0jopeFxQ" supplier="_WXg3JUpqEemahN0jopeFxQ" contract="_WXg3JUpqEemahN0jopeFxQ"/>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_WXj5kEpqEemahN0jopeFxQ" client="_WXg3IkpqEemahN0jopeFxQ" supplier="_WXg3JUpqEemahN0jopeFxQ" contract="_WXg3JUpqEemahN0jopeFxQ"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_WXg3JUpqEemahN0jopeFxQ" name="mCUTE_Commands">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3JkpqEemahN0jopeFxQ" name="newBranch">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3J0pqEemahN0jopeFxQ" name="branch_name">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3KEpqEemahN0jopeFxQ" name="newState">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3KUpqEemahN0jopeFxQ" name="state_name">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3KkpqEemahN0jopeFxQ" name="newTransition">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3K0pqEemahN0jopeFxQ" name="transition_name">
              <type xmi:type="uml:PrimitiveType" href="pathmap://PapyrusC_Cpp_LIBRARIES/AnsiCLibrary.uml#_7wRIABydEduyofBvg4RL2w"/>
            </ownedParameter>
          </ownedOperation>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3LEpqEemahN0jopeFxQ" name="newIteration"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_WXg3LUpqEemahN0jopeFxQ" name="mCUTE_Commands~">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3LkpqEemahN0jopeFxQ" name="reset"/>
          <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3L0pqEemahN0jopeFxQ" name="iterate"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Usage" xmi:id="_WXg3MEpqEemahN0jopeFxQ" client="_WXg3IkpqEemahN0jopeFxQ" supplier="_WXg3LUpqEemahN0jopeFxQ"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_WXg3MUpqEemahN0jopeFxQ" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_WXg3MkpqEemahN0jopeFxQ" name="mCUTE_CommandsIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_WXg3M0pqEemahN0jopeFxQ" client="_WXg3IkpqEemahN0jopeFxQ" supplier="_WXg3MkpqEemahN0jopeFxQ"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_WXg3NEpqEemahN0jopeFxQ" operation="_WXg3JkpqEemahN0jopeFxQ"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_WXg3NUpqEemahN0jopeFxQ" operation="_WXg3KEpqEemahN0jopeFxQ"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_WXg3NkpqEemahN0jopeFxQ" operation="_WXg3KkpqEemahN0jopeFxQ"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_WXg3N0pqEemahN0jopeFxQ" operation="_WXg3LkpqEemahN0jopeFxQ"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_WXg3OEpqEemahN0jopeFxQ" operation="_WXg3LEpqEemahN0jopeFxQ"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_WXg3OUpqEemahN0jopeFxQ" operation="_WXg3L0pqEemahN0jopeFxQ"/>
      </packagedElement>
      <packagedElement xmi:type="uml:Package" xmi:id="_WXg3OkpqEemahN0jopeFxQ" name="mCUTE_Settings">
        <packagedElement xmi:type="uml:Collaboration" xmi:id="_WXg3O0pqEemahN0jopeFxQ" name="mCUTE_Settings">
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_WXj5kUpqEemahN0jopeFxQ" client="_WXg3O0pqEemahN0jopeFxQ" supplier="_WXg3PkpqEemahN0jopeFxQ" contract="_WXg3PkpqEemahN0jopeFxQ"/>
          <interfaceRealization xmi:type="uml:InterfaceRealization" xmi:id="_WXj5kkpqEemahN0jopeFxQ" client="_WXg3O0pqEemahN0jopeFxQ" supplier="_WXg3PkpqEemahN0jopeFxQ" contract="_WXg3PkpqEemahN0jopeFxQ"/>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_WXg3PkpqEemahN0jopeFxQ" name="mCUTE_Settings">
          <ownedOperation xmi:type="uml:Operation" xmi:id="_WXg3P0pqEemahN0jopeFxQ" name="start">
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3QEpqEemahN0jopeFxQ" name="heuristic">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3QUpqEemahN0jopeFxQ" name="strategy">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#String"/>
            </ownedParameter>
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3QkpqEemahN0jopeFxQ" name="execTime">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3Q0pqEemahN0jopeFxQ" name="iterationLength">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3REpqEemahN0jopeFxQ" name="totalIterations">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3RUpqEemahN0jopeFxQ" name="transitionIterations">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
            <ownedParameter xmi:type="uml:Parameter" xmi:id="_WXg3RkpqEemahN0jopeFxQ" name="debug">
              <type xmi:type="uml:PrimitiveType" href="pathmap://UML_LIBRARIES/UMLPrimitiveTypes.library.uml#Integer"/>
            </ownedParameter>
          </ownedOperation>
        </packagedElement>
        <packagedElement xmi:type="uml:Interface" xmi:id="_WXg3R0pqEemahN0jopeFxQ" name="mCUTE_Settings~"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_WXg3SEpqEemahN0jopeFxQ" client="_WXg3O0pqEemahN0jopeFxQ" supplier="_WXg3R0pqEemahN0jopeFxQ"/>
        <packagedElement xmi:type="uml:AnyReceiveEvent" xmi:id="_WXg3SUpqEemahN0jopeFxQ" name="*"/>
        <packagedElement xmi:type="uml:Interface" xmi:id="_WXg3SkpqEemahN0jopeFxQ" name="mCUTE_SettingsIO"/>
        <packagedElement xmi:type="uml:Usage" xmi:id="_WXg3S0pqEemahN0jopeFxQ" client="_WXg3O0pqEemahN0jopeFxQ" supplier="_WXg3SkpqEemahN0jopeFxQ"/>
        <packagedElement xmi:type="uml:CallEvent" xmi:id="_WXg3TEpqEemahN0jopeFxQ" operation="_WXg3P0pqEemahN0jopeFxQ"/>
      </packagedElement>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_WXg3TUpqEemahN0jopeFxQ">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_WXg3TkpqEemahN0jopeFxQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_WXg3T0pqEemahN0jopeFxQ">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_WXg3UEpqEemahN0jopeFxQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
      </profileApplication>
      <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_WXg3UUpqEemahN0jopeFxQ">
        <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_WXg3UkpqEemahN0jopeFxQ" source="http://www.eclipse.org/uml2/2.0.0/UML">
          <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
        </eAnnotations>
        <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
      </profileApplication>
    </packagedElement>
    <packagedElement xmi:type="uml:OpaqueBehavior" xmi:id="_WXuRkEpqEemahN0jopeFxQ" name="SendNextMessageOpaqueBehavior" specification="_WXg3H0pqEemahN0jopeFxQ">
      <language>C++</language>
      <body>vector&lt;value_t> inputs;if (Strategy!=&quot;black-box&quot;){ if (next_t==&quot;t1&quot;){ 
 port1.msg1(-1879797173,1056510574).send();
 log.log(&quot;Harness: msg 'port1.msg1' sent&quot;); 
}
if (next_t==&quot;t3&quot;){ 
 port1.msg12(-1621304007,957870061).send();
 log.log(&quot;Harness: msg 'port1.msg12' sent&quot;); 
}
if (next_t==&quot;t2&quot;){ 
 port1.msg12(841740599,-25354510).send();
 log.log(&quot;Harness: msg 'port1.msg12' sent&quot;); 
}
if (next_t==&quot;t5&quot;){ 
 port1.msg1(1260464628,-901505048).send();
 log.log(&quot;Harness: msg 'port1.msg1' sent&quot;); 
}
if (next_t==&quot;t4&quot;){ 
 port1.msg1(-361004053,1230623820).send();
 log.log(&quot;Harness: msg 'port1.msg1' sent&quot;); 
}
}else{int x;x = rand() % 2 + 0;if (x==0) {port1.msg1(-361004053,1230623820).send(); 
 log.log(&quot;Harness: msg 'port1.msg1' sent&quot;);}if (x==1) {port1.msg12(841740599,-25354510).send(); 
 log.log(&quot;Harness: msg 'port1.msg12' sent&quot;);}}</body>
    </packagedElement>
    <packagedElement xmi:type="uml:OpaqueBehavior" xmi:id="_WXwt0EpqEemahN0jopeFxQ" name="SelectNextTransitionOpaqueBehavior" specification="_WXg3HkpqEemahN0jopeFxQ">
      <language>C++</language>
      <body>vector&lt;string> allTransitions;if (Curr_State == 1){  allTransitions.push_back(&quot;t1&quot;);

 int idx = rand()%allTransitions.size(); next_t = allTransitions.at(idx);
 }if (Curr_State == 2){  allTransitions.push_back(&quot;t2&quot;);

 int idx = rand()%allTransitions.size(); next_t = allTransitions.at(idx);
 }if (Curr_State == 3){  allTransitions.push_back(&quot;t4&quot;);

 int idx = rand()%allTransitions.size(); next_t = allTransitions.at(idx);
 }if (Curr_State == 4){  allTransitions.push_back(&quot;t3&quot;);

 int idx = rand()%allTransitions.size(); next_t = allTransitions.at(idx);
 }if (Curr_State == 5){  allTransitions.push_back(&quot;t5&quot;);

 int idx = rand()%allTransitions.size(); next_t = allTransitions.at(idx);
 }</body>
    </packagedElement>
    <packagedElement xmi:type="uml:OpaqueBehavior" xmi:id="_WXyjAEpqEemahN0jopeFxQ" name="CreateCoverageUtilTableOpaqueBehavior" specification="_WXg3IEpqEemahN0jopeFxQ">
      <language>C++</language>
      <body>coverage_util* cu1_t1 = new coverage_util(string(&quot;t1&quot;)); 
 cu1_t1->initCoverageInfo();CoverageUtilTable.insert(pair&lt;string, coverage_util*>(&quot;t1&quot;,cu1_t1));coverage_util* cu1_t3 = new coverage_util(string(&quot;t3&quot;)); 
 cu1_t3->initCoverageInfo();CoverageUtilTable.insert(pair&lt;string, coverage_util*>(&quot;t3&quot;,cu1_t3));coverage_util* cu1_t2 = new coverage_util(string(&quot;t2&quot;)); 
 cu1_t2->initCoverageInfo();CoverageUtilTable.insert(pair&lt;string, coverage_util*>(&quot;t2&quot;,cu1_t2));coverage_util* cu1_t5 = new coverage_util(string(&quot;t5&quot;)); 
 cu1_t5->initCoverageInfo();CoverageUtilTable.insert(pair&lt;string, coverage_util*>(&quot;t5&quot;,cu1_t5));coverage_util* cu1_t4 = new coverage_util(string(&quot;t4&quot;)); 
 cu1_t4->initCoverageInfo();CoverageUtilTable.insert(pair&lt;string, coverage_util*>(&quot;t4&quot;,cu1_t4));</body>
    </packagedElement>
    <packagedElement xmi:type="uml:CallEvent" xmi:id="_WX2NYEpqEemahN0jopeFxQ" operation="_WXg3L0pqEemahN0jopeFxQ"/>
    <packagedElement xmi:type="uml:CallEvent" xmi:id="_WX2NZEpqEemahN0jopeFxQ" operation="_WXg3L0pqEemahN0jopeFxQ"/>
    <packagedElement xmi:type="uml:CallEvent" xmi:id="_WX20ckpqEemahN0jopeFxQ" operation="_WXg3L0pqEemahN0jopeFxQ"/>
    <packagedElement xmi:type="uml:CallEvent" xmi:id="_WX20dkpqEemahN0jopeFxQ" operation="_WXg3L0pqEemahN0jopeFxQ"/>
    <packagedElement xmi:type="uml:CallEvent" xmi:id="_WX3bg0pqEemahN0jopeFxQ" operation="_WXg3L0pqEemahN0jopeFxQ"/>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_FkT7cw7lEem-ucXEfNJLZw">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_FkT7dA7lEem-ucXEfNJLZw" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/uml-rt.profile.uml#_1h74oEeVEeO0lv5O1DTHOQ"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_FkT7dQ7lEem-ucXEfNJLZw">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_FkT7dg7lEem-ucXEfNJLZw" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/statemachine#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UML_RT_PROFILE/UMLRealTimeSM-addendum.profile.uml#_KLcn0FDtEeOA4ecmvfqvaw"/>
    </profileApplication>
    <profileApplication xmi:type="uml:ProfileApplication" xmi:id="_FkT7dw7lEem-ucXEfNJLZw">
      <eAnnotations xmi:type="ecore:EAnnotation" xmi:id="_FkT7eA7lEem-ucXEfNJLZw" source="http://www.eclipse.org/uml2/2.0.0/UML">
        <references xmi:type="ecore:EPackage" href="http://www.eclipse.org/papyrus/umlrt/cppproperties#/"/>
      </eAnnotations>
      <appliedProfile xmi:type="uml:Profile" href="pathmap://UMLRT_CPP/RTCppProperties.profile.uml#_vl5LALs8EeSTjNEQkASznQ"/>
    </profileApplication>
  </uml:Model>
  <UMLRealTime:Capsule xmi:id="_Ibe84A7lEem-ucXEfNJLZw" base_Class="_IYrggA7lEem-ucXEfNJLZw"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_K_ejoA7lEem-ucXEfNJLZw" base_Pseudostate="_K_ZEEA7lEem-ucXEfNJLZw"/>
  <UMLRTStateMachines:RTState xmi:id="_K_oUoA7lEem-ucXEfNJLZw" base_State="_K_l4YA7lEem-ucXEfNJLZw"/>
  <UMLRTStateMachines:RTRegion xmi:id="_K_r_AA7lEem-ucXEfNJLZw" base_Region="_K_UyoA7lEem-ucXEfNJLZw"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_K_4MQA7lEem-ucXEfNJLZw" base_StateMachine="_K-6i8A7lEem-ucXEfNJLZw"/>
  <UMLRealTime:RTPort xmi:id="_vo_94A7oEem-ucXEfNJLZw" isPublish="false" isWired="false" base_Port="_vo8TgA7oEem-ucXEfNJLZw"/>
  <UMLRealTime:ProtocolContainer xmi:id="_jy580A7sEem-ucXEfNJLZw" base_Package="_jy3gkA7sEem-ucXEfNJLZw"/>
  <UMLRealTime:RTMessageSet xmi:id="_jy-OQA7sEem-ucXEfNJLZw" base_Interface="_jy7yAA7sEem-ucXEfNJLZw"/>
  <UMLRealTime:RTMessageSet xmi:id="_jzEU4A7sEem-ucXEfNJLZw" base_Interface="_jzCfsA7sEem-ucXEfNJLZw" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_jzJNYA7sEem-ucXEfNJLZw" base_Interface="_jzGxIA7sEem-ucXEfNJLZw" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_jzM3wA7sEem-ucXEfNJLZw" base_Collaboration="_jyxZ8A7sEem-ucXEfNJLZw"/>
  <UMLRealTime:RTPort xmi:id="_6Y1A0A7sEem-ucXEfNJLZw" base_Port="_6YxWcA7sEem-ucXEfNJLZw"/>
  <RTCppProperties:CapsuleProperties xmi:id="_x3fZABu9EemGs84svc1UIQ" headerPreface="#include &quot;STATES.hh&quot;&#xA;&#xA;#include &lt;map>&#xA;#include &lt;assert.h>&#xA;#include &lt;vector>&#xA;#include &lt;iostream>&#xA;#include &lt;fstream>&#xA;#include &lt;string>&#xA;&#xA;#include &quot;libcrest/crest.h&quot;" base_Class="_IYrggA7lEem-ucXEfNJLZw" publicDeclarations="int UserIds[100];"/>
  <UMLRTStateMachines:RTState xmi:id="_LkcPABwkEemGs84svc1UIQ" base_State="_LkTsIBwkEemGs84svc1UIQ"/>
  <UMLRTStateMachines:RTState xmi:id="_L8EE0BwkEemGs84svc1UIQ" base_State="_L8BokBwkEemGs84svc1UIQ"/>
  <UMLRTStateMachines:RTState xmi:id="_-ds-EBwqEemGs84svc1UIQ" base_State="_-dosoBwqEemGs84svc1UIQ"/>
  <UMLRealTime:RTPort xmi:id="_G7cAMCNOEem03smGE4oJWg" isPublish="false" isWired="false" base_Port="_G5uI8CNOEem03smGE4oJWg"/>
  <UMLRTStateMachines:RTState xmi:id="_lH1_gCNxEemrUPrz7hly4g" base_State="_lDZkYCNxEemrUPrz7hly4g"/>
  <UMLRealTime:Capsule xmi:id="_WXjScEpqEemahN0jopeFxQ" base_Class="_WXg2NUpqEemahN0jopeFxQ"/>
  <UMLRealTime:Capsule xmi:id="_WXjScUpqEemahN0jopeFxQ" base_Class="_WXg2R0pqEemahN0jopeFxQ"/>
  <UMLRealTime:CapsulePart xmi:id="_WXjSckpqEemahN0jopeFxQ" base_Property="_WXg2NkpqEemahN0jopeFxQ"/>
  <UMLRealTime:ProtocolContainer xmi:id="_WXjSc0pqEemahN0jopeFxQ" base_Package="_WXg3IUpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_WXjSdEpqEemahN0jopeFxQ" base_Interface="_WXg3JUpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_WXjSdUpqEemahN0jopeFxQ" base_Interface="_WXg3LUpqEemahN0jopeFxQ" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_WXjSdkpqEemahN0jopeFxQ" base_Interface="_WXg3MkpqEemahN0jopeFxQ" rtMsgKind="inOut"/>
  <UMLRealTime:Protocol xmi:id="_WXjSd0pqEemahN0jopeFxQ" base_Collaboration="_WXg3IkpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSeEpqEemahN0jopeFxQ" base_Port="_WXg2SEpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXjSeUpqEemahN0jopeFxQ" base_Pseudostate="_WXg2rEpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTRegion xmi:id="_WXjSekpqEemahN0jopeFxQ" base_Region="_WXg2iEpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_WXjSe0pqEemahN0jopeFxQ" base_StateMachine="_WXg2h0pqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXjSfEpqEemahN0jopeFxQ" base_State="_WXg2rUpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSfUpqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2S0pqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSfkpqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2TEpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXjSf0pqEemahN0jopeFxQ" base_Pseudostate="_WXg2QkpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXjSgEpqEemahN0jopeFxQ" base_State="_WXg2Q0pqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTRegion xmi:id="_WXjSgUpqEemahN0jopeFxQ" base_Region="_WXg2PkpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTStateMachine xmi:id="_WXjSgkpqEemahN0jopeFxQ" base_StateMachine="_WXg2PUpqEemahN0jopeFxQ"/>
  <UMLRealTime:ProtocolContainer xmi:id="_WXjSg0pqEemahN0jopeFxQ" base_Package="_WXg3OkpqEemahN0jopeFxQ"/>
  <UMLRealTime:Protocol xmi:id="_WXjShEpqEemahN0jopeFxQ" base_Collaboration="_WXg3O0pqEemahN0jopeFxQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_WXjShUpqEemahN0jopeFxQ" base_Interface="_WXg3PkpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTMessageSet xmi:id="_WXjShkpqEemahN0jopeFxQ" base_Interface="_WXg3R0pqEemahN0jopeFxQ" rtMsgKind="out"/>
  <UMLRealTime:RTMessageSet xmi:id="_WXjSh0pqEemahN0jopeFxQ" base_Interface="_WXg3SkpqEemahN0jopeFxQ" rtMsgKind="inOut"/>
  <UMLRealTime:RTPort xmi:id="_WXjSiEpqEemahN0jopeFxQ" base_Port="_WXg2UUpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSiUpqEemahN0jopeFxQ" base_Port="_WXg2N0pqEemahN0jopeFxQ"/>
  <UMLRealTime:RTConnector xmi:id="_WXjSikpqEemahN0jopeFxQ" base_Connector="_WXg2OkpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSi0pqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2OEpqEemahN0jopeFxQ"/>
  <RTCppProperties:CapsuleProperties xmi:id="_WXjSjEpqEemahN0jopeFxQ" headerPreface="#include &quot;umlrtmain.hh&quot;" base_Class="_WXg2NUpqEemahN0jopeFxQ"/>
  <RTCppProperties:CapsuleProperties xmi:id="_WXjSjUpqEemahN0jopeFxQ" headerPreface="#include &lt;assert.h>&#xA;#include &lt;stdio.h>&#xA;//#include &lt;sys/time.h>&#xA;#include &lt;iostream>&#xA;#include &lt;fstream>&#xA;#include &lt;string>&#xA;#include &lt;vector>&#xA;#include &lt;map>&#xA;#include &lt;algorithm>&#xA;&#xA;&#xA;#include &lt;limits>&#xA;#include &lt;cstdlib>&#xA;&#xA;#include &lt;ctime>&#xA;&#xA;#include &lt;concolic_search.h>&#xA;#include &lt;coverage_util.h>&#xA;#include &lt;branch_util.h>&#xA;//#include &lt;transition_util.h>&#xA;#include &lt;STATES.hh>&#xA;#include &lt;data_generator.h>&#xA;&#xA;#include &quot;base/basic_types.h&quot;&#xA;#include &quot;base/symbolic_execution.h&quot;&#xA;#include &quot;base/symbolic_expression.h&quot;&#xA;#include &quot;base/symbolic_interpreter.h&quot;&#xA;#include &quot;base/symbolic_path.h&quot;&#xA;#include &quot;base/symbolic_predicate.h&quot;&#xA;#include &quot;base/yices_solver.h&quot;&#xA;&#xA;&#xA;using namespace mcute;" headerEnding="" implementationPreface="using namespace std;&#xA;using namespace mcute;" base_Class="_WXg2R0pqEemahN0jopeFxQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_WXjSjkpqEemahN0jopeFxQ" type="string" base_Property="_WXg2UkpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXjSj0pqEemahN0jopeFxQ" base_State="_WXg2r0pqEemahN0jopeFxQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_WXjSkEpqEemahN0jopeFxQ" type="vector&lt;int>" base_Property="_WXg2WEpqEemahN0jopeFxQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_WXjSkUpqEemahN0jopeFxQ" type="vector&lt;string>" base_Property="_WXg2WUpqEemahN0jopeFxQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_WXjSkkpqEemahN0jopeFxQ" type="vector&lt;int>" base_Property="_WXg2WkpqEemahN0jopeFxQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_WXjSk0pqEemahN0jopeFxQ" type="map&lt;int,int>" base_Property="_WXg2V0pqEemahN0jopeFxQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_WXjSlEpqEemahN0jopeFxQ" type="mcute::Search*" base_Property="_WXg2W0pqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSlUpqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2akpqEemahN0jopeFxQ"/>
  <RTCppProperties:ParameterProperties xmi:id="_WXjSlkpqEemahN0jopeFxQ" type="const SymbolicExecution&amp;" base_Parameter="_WXg3F0pqEemahN0jopeFxQ"/>
  <RTCppProperties:ParameterProperties xmi:id="_WXjSl0pqEemahN0jopeFxQ" type="size_t" base_Parameter="_WXg3GEpqEemahN0jopeFxQ"/>
  <RTCppProperties:ParameterProperties xmi:id="_WXjSmEpqEemahN0jopeFxQ" type="vector&lt;value_t>&amp;" base_Parameter="_WXg3GUpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSmUpqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2a0pqEemahN0jopeFxQ"/>
  <RTCppProperties:ParameterProperties xmi:id="_WXjSmkpqEemahN0jopeFxQ" type="SymbolicExecution&amp;" base_Parameter="_WXg3HUpqEemahN0jopeFxQ"/>
  <RTCppProperties:ParameterProperties xmi:id="_WXjSm0pqEemahN0jopeFxQ" type="size_t" base_Parameter="_WXg3G0pqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSnEpqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2dkpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXjSnUpqEemahN0jopeFxQ" base_State="_WXg2sEpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXjSnkpqEemahN0jopeFxQ" base_State="_WXg2RUpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSn0pqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2OUpqEemahN0jopeFxQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_WXjSoEpqEemahN0jopeFxQ" type="vector&lt;coverage_util>" base_Property="_WXg2eUpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXjSoUpqEemahN0jopeFxQ" base_State="_WXg2sUpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXjSokpqEemahN0jopeFxQ" base_Pseudostate="_WXg21UpqEemahN0jopeFxQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_WXjSo0pqEemahN0jopeFxQ" type="string" base_Property="_WXg2fkpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTRegion xmi:id="_WXjSpEpqEemahN0jopeFxQ" base_Region="_WXg2tUpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXjSpUpqEemahN0jopeFxQ" base_Pseudostate="_WXg2skpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXjSpkpqEemahN0jopeFxQ" base_State="_WXg2yEpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXjSp0pqEemahN0jopeFxQ" base_State="_WXg2ykpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSqEpqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2f0pqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXjSqUpqEemahN0jopeFxQ" base_Pseudostate="_WXg2zEpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXjSqkpqEemahN0jopeFxQ" base_Pseudostate="_WXg2s0pqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXjSq0pqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2gEpqEemahN0jopeFxQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_WXjSrEpqEemahN0jopeFxQ" type="map&lt;string,coverage_util*>" base_Property="_WXg2e0pqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXjSrUpqEemahN0jopeFxQ" base_State="_WXg21kpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTRegion xmi:id="_WXjSrkpqEemahN0jopeFxQ" base_Region="_WXg22kpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXjSr0pqEemahN0jopeFxQ" base_Pseudostate="_WXg210pqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXjSsEpqEemahN0jopeFxQ" base_State="_WXg27UpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXj5gEpqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2g0pqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXj5gUpqEemahN0jopeFxQ" base_State="_WXg270pqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXj5gkpqEemahN0jopeFxQ" base_Pseudostate="_WXg22EpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXj5g0pqEemahN0jopeFxQ" base_State="_WXg28UpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXj5hEpqEemahN0jopeFxQ" base_Pseudostate="_WXg280pqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXj5hUpqEemahN0jopeFxQ" base_State="_WXg29EpqEemahN0jopeFxQ"/>
  <RTCppProperties:AttributeProperties xmi:id="_WXj5hkpqEemahN0jopeFxQ" type="SymbolicExecution" base_Property="_WXg2hEpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXj5h0pqEemahN0jopeFxQ" base_State="_WXg3DUpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXj5iEpqEemahN0jopeFxQ" base_Pseudostate="_WXg29kpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTRegion xmi:id="_WXj5iUpqEemahN0jopeFxQ" base_Region="_WXg2-UpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXj5ikpqEemahN0jopeFxQ" base_Pseudostate="_WXg3D0pqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTPseudostate xmi:id="_WXj5i0pqEemahN0jopeFxQ" base_Pseudostate="_WXg290pqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXj5jEpqEemahN0jopeFxQ" base_State="_WXg29UpqEemahN0jopeFxQ"/>
  <UMLRTStateMachines:RTState xmi:id="_WXj5jUpqEemahN0jopeFxQ" base_State="_WXg3C0pqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXj5jkpqEemahN0jopeFxQ" isWired="false" base_Port="_WXg2hUpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXmVwEpqEemahN0jopeFxQ" base_Port="_WXlHoEpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXm80UpqEemahN0jopeFxQ" base_Port="_WXm80EpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXnj4EpqEemahN0jopeFxQ" base_Port="_WXm80kpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXnj4kpqEemahN0jopeFxQ" base_Port="_WXnj4UpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTPort xmi:id="_WXoK8EpqEemahN0jopeFxQ" base_Port="_WXnj40pqEemahN0jopeFxQ"/>
  <UMLRealTime:CapsulePart xmi:id="_WXoyAEpqEemahN0jopeFxQ" base_Property="_WXoK8UpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTConnector xmi:id="_WXpZEEpqEemahN0jopeFxQ" base_Connector="_WXoyAUpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTConnector xmi:id="_WXpZFEpqEemahN0jopeFxQ" base_Connector="_WXpZEUpqEemahN0jopeFxQ"/>
  <UMLRealTime:RTConnector xmi:id="_WXqAIkpqEemahN0jopeFxQ" base_Connector="_WXpZFUpqEemahN0jopeFxQ"/>
</xmi:XMI>
